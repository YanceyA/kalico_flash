# Milestone v1.0: klipper-flash MVP

**Status:** SHIPPED 2026-01-25
**Phases:** 1-3
**Total Plans:** 8

## Overview

klipper-flash delivers a Python CLI tool that replaces the manual Klipper firmware build-and-flash workflow with a single-command experience. The roadmap progresses from foundational data modules (device registry, discovery, config caching) through firmware build pipeline, to flash execution with service safety guarantees and end-to-end CLI orchestration. Architecture constraints (stdlib-only, hub-and-spoke, pluggable output) are enforced from Phase 1 onward.

## Phases

### Phase 1: Foundation & Device Management

**Goal**: User can register, list, remove, and discover USB-connected MCU boards through importable Python modules with clean data contracts
**Depends on**: Nothing (first phase)
**Requirements**: ARCH-01, ARCH-02, ARCH-03, ARCH-04, ARCH-05, ARCH-06, RGST-01, RGST-02, RGST-03, RGST-04, RGST-05, DISC-01, DISC-02, DISC-03, DISC-04
**Plans:** 3 plans

Plans:
- [x] 01-01-PLAN.md -- Architecture skeleton and all five library modules (errors, models, output, registry, discovery)
- [x] 01-02-PLAN.md -- CLI entry point with argparse, add-device wizard, and remove-device command
- [x] 01-03-PLAN.md -- List-devices with discovery integration, connection status, and edge cases

**Success Criteria:**
1. Running --list-devices shows all registered devices with connection status
2. Running --add-device walks through interactive wizard and persists to devices.json
3. Running --remove-device NAME deletes device from registry
4. Scanning /dev/serial/by-id/ identifies registered devices and flags unknown devices
5. All modules importable with callable interfaces, dataclass contracts, pluggable output

### Phase 2: Build & Config Pipeline

**Goal**: User can configure firmware via menuconfig and build it, with per-device config caching and MCU validation preventing wrong-board firmware
**Depends on**: Phase 1
**Requirements**: CONF-01, CONF-02, CONF-03, BILD-01, BILD-02, BILD-03, BILD-04
**Plans:** 3 plans

Plans:
- [x] 02-01-PLAN.md -- Config manager module (config.py) with XDG caching, atomic writes, MCU parsing and validation
- [x] 02-02-PLAN.md -- Builder module (build.py) with menuconfig passthrough, make clean, make build, streaming output
- [x] 02-03-PLAN.md -- Gap closure: Wire config.py and build.py into flash.py CLI orchestrator

**Success Criteria:**
1. Build cycle copies cached .config, launches menuconfig, caches result with atomic writes
2. make clean + make -j$(nproc) executes with real-time streaming output
3. klipper.bin file size reported after successful build
4. MCU mismatch refuses to proceed with clear error message

### Phase 3: Flash & Orchestration

**Goal**: User runs one command to build and flash any registered board with guaranteed klipper service restart on all code paths
**Depends on**: Phase 2
**Requirements**: FLSH-01, FLSH-02, FLSH-03, SRVC-01, SRVC-02, SRVC-03, DISC-05, CLUX-01, CLUX-02, CLUX-03, CLUX-04
**Plans:** 2 plans

Plans:
- [x] 03-01-PLAN.md -- Service lifecycle context manager (service.py), dual-method flasher (flasher.py), error/model extensions
- [x] 03-02-PLAN.md -- CLI orchestrator (flash.py) with end-to-end workflow, interactive device selection, phase labels, timeouts

**Success Criteria:**
1. flash.py orchestrates full workflow with --device NAME or interactive selection
2. Klipper service always restarted (success, failure, exception, Ctrl+C) via context manager
3. Katapult first, make flash fallback, using /dev/serial/by-id/ stable paths
4. Device path re-verified before flash, passwordless sudo verified, all subprocesses have timeouts
5. Phase labels [Discovery], [Config], [Build], [Flash], clear error messages, success/failure summary

---

## Milestone Summary

**Key Decisions:**

- Used models.py instead of types.py to avoid shadowing stdlib types module
- Stored paths as str not Path in dataclasses for JSON serialization
- Used typing.Optional for field defaults for Python 3.9 runtime compatibility
- TTY check returns error for non-interactive stdin
- MCU validation uses bidirectional prefix matching (stm32h723 matches stm32h723xx)
- Inherited stdio pattern for TUI passthrough (no PIPE redirection)
- _start_klipper warns but doesn't raise (safe for finally block)
- Flash timeout applies per-method, not total

**Issues Resolved:**

- Config.py and build.py initially orphaned — wired via gap closure plan 02-03
- MCU validation initially not called — wired in cmd_build and cmd_flash

**Technical Debt:**

- cmd_build() orphaned (no --build-only argparse flag) — 89 lines unused
- Builder class orphaned — defined but never imported/used
- DeviceNotFoundError, BuildError, FlashError defined but never raised

---

*Archived: 2026-01-25 as part of v1.0 milestone completion*
*For current project status, see .planning/ROADMAP.md*
