---
phase: 19-edit-interaction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kflash/tui.py
autonomous: true

must_haves:
  truths:
    - "Pressing 1 on device config screen prompts for display name, empty input keeps current, non-empty updates pending"
    - "Pressing 2 prompts for new key with format and uniqueness validation, stores in pending"
    - "Pressing 3 cycles flash_method through default/katapult/make_flash without prompting"
    - "Pressing 4 toggles flashable without prompting"
    - "Pressing 5 launches make menuconfig using original_key for config cache lookup"
    - "Esc/B saves all pending changes atomically then returns"
    - "Ctrl+C returns without saving pending changes"
    - "Key rename moves config cache dir before updating registry"
  artifacts:
    - path: "kflash/tui.py"
      provides: "_device_config_screen function with collect-then-save interaction loop"
      contains: "_device_config_screen"
  key_links:
    - from: "kflash/tui.py::_device_config_screen"
      to: "kflash/screen.py::render_device_config_screen"
      via: "render call in loop"
      pattern: "render_device_config_screen"
    - from: "kflash/tui.py::_device_config_screen"
      to: "kflash/validation.py::validate_device_key"
      via: "key edit validation"
      pattern: "validate_device_key"
    - from: "kflash/tui.py::_device_config_screen"
      to: "kflash/config.py::rename_device_config_cache"
      via: "key rename save"
      pattern: "rename_device_config_cache"
    - from: "kflash/tui.py::_device_config_screen"
      to: "kflash/registry.py::Registry.update_device"
      via: "save on exit (non-rename case)"
      pattern: "update_device"
---

<objective>
Implement the device config screen interaction loop with all five edit types and collect-then-save persistence.

Purpose: This is the core user interaction for Phase 19 — users can modify device properties through numbered keypress dispatch, with all changes batched and saved atomically on screen exit.

Output: `_device_config_screen()` function added to `kflash/tui.py`
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-edit-interaction/19-RESEARCH.md

# Key source files
@kflash/tui.py — _config_screen() at lines 597-694 is the DIRECT ANALOG. Follow same render-read-dispatch loop structure.
@kflash/screen.py — DEVICE_SETTINGS (lines 461-467) and render_device_config_screen() (lines 474-513)
@kflash/registry.py — Registry.load(), Registry.save(), Registry.update_device() (lines 143-156)
@kflash/validation.py — validate_device_key() (lines 55-82)
@kflash/config.py — rename_device_config_cache() (lines 30-48), ConfigManager class
@kflash/models.py — DeviceEntry dataclass (lines 23-32)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement _device_config_screen with collect-then-save loop</name>
  <files>kflash/tui.py</files>
  <action>
Add a `_device_config_screen(device_key: str, registry, out) -> None` function in tui.py, placed after the existing `_config_screen()` function (after line ~694).

**Structure — model directly on `_config_screen()` (lines 597-694):**

1. **Imports at top of function** (late import pattern, same as _config_screen):
   - `from .screen import render_device_config_screen, DEVICE_SETTINGS`
   - `from .panels import render_action_divider`
   - `import dataclasses`

2. **State initialization:**
   - `original_key = device_key` — never changes, used for menuconfig and save
   - `original = registry.get(device_key)` — the unmodified DeviceEntry
   - `pending: dict[str, Any] = {}` — accumulates edits keyed by field name
   - `theme = get_theme()`

3. **Main loop** (`while True`):
   a. Build working copy: `working = dataclasses.replace(original, **{k: v for k, v in pending.items() if k != "key"})` — overlay pending on original. For key field: if "key" in pending, also set `working = dataclasses.replace(working, key=pending["key"])`.
   b. `clear_screen()`, print action divider, print `render_device_config_screen(working)`.
   c. Print prompt: `"  Setting # (or Esc/B to save & return): "` using theme.prompt.
   d. Read keypress with `_getch()`, wrapped in try/except (EOFError, OSError) -> return.

4. **Exit handling:**
   - **Esc or "b"**: Save pending changes (call `_save_device_edits`), then return.
   - **Ctrl+C ("\x03")**: Return WITHOUT saving (discard pending — escape hatch).

5. **Dispatch on keys "1" through "5":**
   Use `DEVICE_SETTINGS` list to look up setting by index. Dispatch by setting["type"]:

   - **"1" — name (type=text):** Print the key digit. Prompt with `input()` wrapped in try/except (EOFError, KeyboardInterrupt -> break to main loop). Show current as `working.name`. If user enters empty string (after strip), keep current (break). If non-empty, set `pending["name"] = raw`.

   - **"2" — key (type=text):** Print the key digit. Prompt loop with `input()` wrapped in try/except. Show current as `working.key`. If empty, keep current. Otherwise call `validate_device_key(raw, registry, current_key=original_key)`. If valid, set `pending["key"] = raw`. If invalid, print error and reprompt.

   - **"3" — flash_method (type=cycle):** No prompt. Read values from `setting["values"]` which is `[None, "katapult", "make_flash"]`. Find current value's index in list, advance to next with modulo. Set `pending["flash_method"] = next_value`. Continue loop immediately (screen re-renders showing new value).

   - **"4" — flashable (type=toggle):** No prompt. Set `pending["flashable"] = not working.flashable`. Continue loop immediately.

   - **"5" — menuconfig (type=action):** Launch menuconfig using the ORIGINAL key (not pending key — cache hasn't been renamed yet). Use `ConfigManager` from config module:
     ```python
     from .config import ConfigManager
     gc = registry.load_global()
     cm = ConfigManager(gc.klipper_dir, original_key)
     cm.run_menuconfig()
     ```
     Wrap in try/except for BuildError — print error and continue.

6. **_save_device_edits helper function** (private, defined before _device_config_screen):

   ```python
   def _save_device_edits(original_key: str, pending: dict, registry) -> None:
       if not pending:
           return
       new_key = pending.pop("key", None)
       if new_key and new_key != original_key:
           # Move config cache first (safe: registry unchanged if this fails)
           from .config import rename_device_config_cache
           try:
               rename_device_config_cache(original_key, new_key)
           except FileExistsError:
               # Cache collision — should not happen if validation passed, but recover
               pending["key"] = new_key  # restore for retry
               raise
           # Atomic registry: load, delete old, insert new with all updates
           data = registry.load()
           device = data.devices.pop(original_key)
           for field, value in pending.items():
               setattr(device, field, value)
           device.key = new_key
           data.devices[new_key] = device
           registry.save(data)
       else:
           # No key rename — simple field update
           registry.update_device(original_key, **pending)
   ```

**CRITICAL pitfalls to handle (from research):**
- Always use `original_key` for menuconfig config cache lookup (cache not renamed yet)
- Never mutate `original` — use `dataclasses.replace()` for working copy
- Ctrl+C during `input()` should catch KeyboardInterrupt and break to main loop (preserving pending)
- Key "key" in pending needs special handling when building working copy since DeviceEntry.key exists
  </action>
  <verify>
  Read the function and verify:
  1. `pending` dict is initialized empty and only modified by edit dispatch
  2. Esc/B calls _save_device_edits, Ctrl+C returns without save
  3. All 5 setting types dispatched: text (name), text+validate (key), cycle (flash_method), toggle (flashable), action (menuconfig)
  4. _save_device_edits handles key rename (move cache -> atomic registry) and non-rename (update_device) separately
  5. menuconfig uses original_key not pending key
  6. input() calls wrapped in try/except (EOFError, KeyboardInterrupt)
  </verify>
  <done>
  _device_config_screen function exists in tui.py with:
  - Render-read-dispatch loop using DEVICE_SETTINGS and render_device_config_screen
  - Collect-then-save pattern (pending dict saved on Esc/B exit only)
  - All 5 edit types implemented (text, text+validate, cycle, toggle, action)
  - Key rename with cache migration and atomic registry save
  - Ctrl+C discards, Esc/B saves
  - KeyboardInterrupt protection on all input() calls
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify syntax and imports</name>
  <files>kflash/tui.py</files>
  <action>
Run `python -c "from kflash import tui"` to verify the module loads without syntax errors. If there are import issues, fix them.

Also verify `_device_config_screen` is NOT yet wired to any menu handler (that's Phase 20). It should be a standalone function ready to be called.

Check that the `from __future__ import annotations` import is present at the top of tui.py (needed for `dict[str, Any]` type hints on Python 3.9).
  </action>
  <verify>
  `python -c "from kflash import tui; print('OK')"` prints OK without errors.
  `grep -n "_device_config_screen" kflash/tui.py` shows the function definition.
  </verify>
  <done>
  tui.py loads without errors and _device_config_screen is defined but not yet wired to menu.
  </done>
</task>

</tasks>

<verification>
1. Module loads: `python -c "from kflash import tui"` succeeds
2. Function exists: `grep "_device_config_screen" kflash/tui.py` finds definition
3. Save helper exists: `grep "_save_device_edits" kflash/tui.py` finds definition
4. Collect-then-save: `grep "pending" kflash/tui.py` shows dict usage in new function
5. Key rename: `grep "rename_device_config_cache" kflash/tui.py` shows import in save helper
6. Original key protection: `grep "original_key" kflash/tui.py` shows usage for menuconfig and save
</verification>

<success_criteria>
- _device_config_screen() implements all 5 edit types from DEVICE_SETTINGS
- Collect-then-save: pending dict saved atomically on Esc/B, discarded on Ctrl+C
- Key rename uses correct ordering: validate -> move cache -> atomic registry save
- Menuconfig uses original_key for cache lookup
- All input() calls protected against KeyboardInterrupt/EOFError
- Module loads without syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-edit-interaction/19-01-SUMMARY.md`
</output>
