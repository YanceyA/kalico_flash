---
phase: 04-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - kalico-flash/models.py
  - kalico-flash/registry.py
autonomous: true

must_haves:
  truths:
    - "DeviceEntry has flashable field defaulting to True"
    - "Existing devices.json files load without error (backward compatible)"
    - "New devices save with flashable field in JSON"
    - "Registry.get() returns device with correct flashable value"
  artifacts:
    - path: "kalico-flash/models.py"
      provides: "DeviceEntry dataclass with flashable field"
      contains: "flashable: bool = True"
    - path: "kalico-flash/registry.py"
      provides: "Backward-compatible JSON load/save for flashable field"
      contains: "flashable"
  key_links:
    - from: "kalico-flash/registry.py"
      to: "kalico-flash/models.py"
      via: "DeviceEntry import and instantiation"
      pattern: "DeviceEntry"
---

<objective>
Add device exclusion schema to registry with backward-compatible JSON persistence.

Purpose: Enable devices like Beacon probes to be marked as non-flashable. This schema change must not break existing devices.json files that lack the flashable field.

Output: DeviceEntry with flashable field, registry load/save that handles missing field gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-foundation/04-CONTEXT.md
@.planning/phases/04-foundation/04-RESEARCH.md
@kalico-flash/models.py
@kalico-flash/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flashable field to DeviceEntry dataclass</name>
  <files>kalico-flash/models.py</files>
  <action>
Add flashable field to DeviceEntry:

1. Add the field at END of DeviceEntry (after flash_method) to maintain dataclass field ordering:
   ```python
   @dataclass
   class DeviceEntry:
       key: str
       name: str
       mcu: str
       serial_pattern: str
       flash_method: Optional[str] = None
       flashable: bool = True  # New field - non-flashable devices excluded from flash selection
   ```

2. The default=True ensures backward compatibility: existing code that creates DeviceEntry without specifying flashable gets True (normal behavior).

3. Do NOT change any other dataclasses in models.py.

Per RESEARCH.md pitfall: New fields with defaults must go at END of dataclass to avoid "non-default argument follows default argument" TypeError.
  </action>
  <verify>
Run: python -c "from models import DeviceEntry; e = DeviceEntry(key='test', name='Test', mcu='stm32', serial_pattern='usb-*'); print(e.flashable)"

Should print: True
  </verify>
  <done>DeviceEntry has flashable: bool = True field at end of dataclass</done>
</task>

<task type="auto">
  <name>Task 2: Update Registry.load() for backward-compatible flashable field</name>
  <files>kalico-flash/registry.py</files>
  <action>
Update load() to handle flashable field with backward compatibility:

1. In the load() method, update the DeviceEntry creation in the devices loop:
   ```python
   devices[key] = DeviceEntry(
       key=key,
       name=data["name"],
       mcu=data["mcu"],
       serial_pattern=data["serial_pattern"],
       flash_method=data.get("flash_method"),
       flashable=data.get("flashable", True),  # Default to True if missing
   )
   ```

2. The .get("flashable", True) pattern means:
   - Old devices.json files without "flashable" key get flashable=True (normal behavior)
   - New files with explicit "flashable": false get flashable=False

This is the backward-compatible schema evolution pattern from RESEARCH.md.
  </action>
  <verify>
Create test JSON without flashable field, load it:
```
echo '{"global": {"klipper_dir": "~/klipper", "katapult_dir": "~/katapult"}, "devices": {"test": {"name": "Test", "mcu": "stm32", "serial_pattern": "usb-*"}}}' > /tmp/test_registry.json
python -c "from registry import Registry; r = Registry('/tmp/test_registry.json'); d = r.get('test'); print(d.flashable)"
```
Should print: True
  </verify>
  <done>Registry.load() handles missing flashable field with default True</done>
</task>

<task type="auto">
  <name>Task 3: Update Registry.save() to persist flashable field</name>
  <files>kalico-flash/registry.py</files>
  <action>
Update save() to include flashable field in JSON output:

1. In the save() method, update the device dict creation:
   ```python
   for key, device in sorted(registry.devices.items()):
       data["devices"][key] = {
           "name": device.name,
           "mcu": device.mcu,
           "serial_pattern": device.serial_pattern,
           "flash_method": device.flash_method,
           "flashable": device.flashable,  # Always save explicitly
       }
   ```

2. Always save flashable explicitly (even if True) for consistency and future-proofing.

3. Add set_flashable() convenience method to Registry class:
   ```python
   def set_flashable(self, key: str, flashable: bool) -> bool:
       """Set flashable status for a device. Returns False if device not found."""
       registry = self.load()
       if key not in registry.devices:
           return False
       registry.devices[key].flashable = flashable
       self.save(registry)
       return True
   ```

This method will be used by --exclude-device and --include-device commands in Plan 03.
  </action>
  <verify>
Run roundtrip test:
```
python -c "
from registry import Registry
from models import DeviceEntry
import tempfile
import json

with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
    f.write('{}')
    path = f.name

r = Registry(path)
e = DeviceEntry(key='beacon', name='Beacon', mcu='stm32', serial_pattern='usb-*', flashable=False)
r.add(e)

# Reload and check
r2 = Registry(path)
d = r2.get('beacon')
print(f'flashable={d.flashable}')

# Check JSON directly
with open(path) as f:
    data = json.load(f)
    print(f'json_flashable={data[\"devices\"][\"beacon\"][\"flashable\"]}')
"
```
Should print: flashable=False and json_flashable=False
  </verify>
  <done>Registry.save() persists flashable field, set_flashable() method exists</done>
</task>

</tasks>

<verification>
1. Syntax check: `python -m py_compile kalico-flash/models.py kalico-flash/registry.py`
2. Import test: `python -c "from models import DeviceEntry; from registry import Registry"`
3. Backward compatibility: Load existing devices.json (if exists) and verify no errors
4. Roundtrip: Create device with flashable=False, save, reload, verify flashable=False
</verification>

<success_criteria>
- DeviceEntry has flashable: bool = True field
- Existing devices.json files load without error
- New devices.json includes flashable field in JSON
- Registry.set_flashable() method exists and works
- All code passes Python syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-02-SUMMARY.md`
</output>
