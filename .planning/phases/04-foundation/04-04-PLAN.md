---
phase: 04-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - kalico-flash/errors.py
  - kalico-flash/flash.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User sees numbered recovery steps (1., 2., 3.) on any error"
    - "All error messages fit within 80-column terminal width"
    - "Error messages include context (device name, MCU type, path)"
  artifacts:
    - path: "kalico-flash/errors.py"
      provides: "ERROR_TEMPLATES with numbered recovery steps"
      contains: "1. "
    - path: "kalico-flash/flash.py"
      provides: "All error paths use error_with_recovery()"
      pattern: "error_with_recovery"
  key_links:
    - from: "kalico-flash/flash.py"
      to: "output.py error_with_recovery()"
      via: "out.error_with_recovery() calls"
      pattern: "out\\.error_with_recovery\\("
---

<objective>
Close verification gap: Integrate error framework into flash.py error paths

The error message framework (format_error, ERROR_TEMPLATES, error_with_recovery) was built
in Plan 04-01 but only 1 of 40 error paths uses it. This plan wires the framework into all
flash.py error paths and converts ERROR_TEMPLATES recovery text to numbered steps.

Purpose: Users hitting any error see numbered recovery steps with diagnostic commands
Output: All flash.py errors use error_with_recovery() with context and numbered recovery
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation/04-01-SUMMARY.md
@.planning/phases/04-foundation/04-VERIFICATION.md

# Source files
@kalico-flash/errors.py
@kalico-flash/flash.py
@kalico-flash/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert ERROR_TEMPLATES recovery text to numbered steps</name>
  <files>kalico-flash/errors.py</files>
  <action>
Update all ERROR_TEMPLATES recovery_template values to use numbered steps instead of prose
paragraphs. Each template should have 3-5 numbered recovery steps.

Format pattern for each recovery_template:
```
"1. First recovery action with specific command\n"
"2. Second recovery action\n"
"3. Third recovery action with diagnostic command"
```

Specific conversions needed:

build_failed:
1. Check the build output above for the specific error message
2. Run `make menuconfig` in ~/klipper to verify configuration
3. Ensure toolchain is installed: `arm-none-eabi-gcc --version`
4. Clean and retry: `cd ~/klipper && make clean && make`

menuconfig_failed:
1. Install ncurses: `sudo apt install libncurses-dev`
2. Verify Klipper directory exists: `ls ~/klipper/Makefile`
3. Try running menuconfig directly: `cd ~/klipper && make menuconfig`

device_not_registered:
1. List registered devices: `python flash.py --list-devices`
2. Register new device: `python flash.py --add-device`
3. Check device key spelling (case-sensitive)

device_not_connected:
1. Check USB connection and board power
2. List connected devices: `ls /dev/serial/by-id/`
3. If device shows with different name, re-register with `--add-device`

mcu_mismatch:
1. Run without --skip-menuconfig to reconfigure
2. Or update device registration if MCU changed
3. Verify config: `grep CONFIG_MCU ~/klipper/.config`

service_stop_failed:
1. Check service status: `sudo systemctl status klipper`
2. Verify passwordless sudo: `sudo -n systemctl stop klipper`
3. Try manual stop: `sudo systemctl stop klipper`

service_start_failed:
1. Start manually: `sudo systemctl start klipper`
2. Check logs: `sudo journalctl -u klipper -n 50`
3. Firmware was flashed - issue is service, not board

flash_failed:
1. Power cycle the board with BOOT button held
2. Check bootloader mode: `ls /dev/serial/by-id/ | grep -i katapult`
3. For DFU mode, check: `lsusb | grep -i stm32`
4. Retry flash after board enters bootloader

katapult_not_found:
1. Falling back to make flash method
2. To use Katapult, install at ~/katapult
3. Verify: `ls ~/katapult/scripts/flashtool.py`

device_excluded:
1. Include device: `python flash.py --include-device {device}`
2. List all devices: `python flash.py --list-devices`
3. Device was excluded to prevent accidental flash

Also update moonraker_unavailable and printer_busy templates similarly.
  </action>
  <verify>
Run: `python -c "from errors import ERROR_TEMPLATES; print(ERROR_TEMPLATES['build_failed']['recovery_template'])"`
Output should show numbered steps (1., 2., 3.) not prose paragraphs.
  </verify>
  <done>All 12 ERROR_TEMPLATES have recovery_template with numbered steps (1., 2., 3. format)</done>
</task>

<task type="auto">
  <name>Task 2: Replace out.error() calls with error_with_recovery() in flash.py</name>
  <files>kalico-flash/flash.py</files>
  <action>
Replace all out.error() calls with out.error_with_recovery() using ERROR_TEMPLATES.
Group by error category and apply appropriate template.

**Build/Config errors (menuconfig, MCU validation, build failures):**

Replace:
```python
out.error(f"menuconfig exited with code {ret_code}")
```
With:
```python
template = ERROR_TEMPLATES["menuconfig_failed"]
out.error_with_recovery(
    template["error_type"],
    template["message_template"],
    context={"device": device_key},
    recovery=template["recovery_template"],
)
```

Replace MCU mismatch errors:
```python
out.error(f"Refusing to build: Config MCU '{actual}' != registered '{expected}'")
```
With:
```python
template = ERROR_TEMPLATES["mcu_mismatch"]
out.error_with_recovery(
    template["error_type"],
    template["message_template"].format(actual=actual, expected=expected),
    context={"device": device_key, "expected": expected, "actual": actual},
    recovery=template["recovery_template"],
)
```

**Device errors (not found, not connected, excluded):**

Replace:
```python
out.error(f"Device '{device_key}' not found.")
```
With:
```python
template = ERROR_TEMPLATES["device_not_registered"]
out.error_with_recovery(
    template["error_type"],
    template["message_template"].format(device=device_key),
    context={"device": device_key},
    recovery=template["recovery_template"],
)
```

Replace:
```python
out.error(f"Device '{device_key}' is not connected.")
```
With:
```python
template = ERROR_TEMPLATES["device_not_connected"]
out.error_with_recovery(
    template["error_type"],
    template["message_template"].format(device=device_key),
    context={"device": device_key},
    recovery=template["recovery_template"],
)
```

**Flash errors:**

Replace:
```python
out.error(f"Flash failed: {flash_result.error_message}")
out.error(f"Method attempted: {flash_result.method}")
out.error("Recovery: Power cycle the board and try again.")
```
With:
```python
template = ERROR_TEMPLATES["flash_failed"]
out.error_with_recovery(
    template["error_type"],
    template["message_template"].format(device=device_key),
    context={"device": device_key, "method": flash_result.method},
    recovery=template["recovery_template"],
)
```

**Service errors:**

For service-related catch blocks, use service_stop_failed or service_start_failed templates.

**Simple errors that don't need templates (keep as out.error()):**

- "Interactive terminal required" - user info, no recovery needed
- "Global config not set" - simple, has clear action
- "No USB devices found" - simple, action is obvious
- "Too many invalid selections" - user input error

**Import ERROR_TEMPLATES at top of flash.py:**
Add to imports: `from errors import ERROR_TEMPLATES`

Total: Convert approximately 25-30 error paths. Keep ~10 simple errors as out.error().
  </action>
  <verify>
Run: `grep -c "out.error_with_recovery" kalico-flash/flash.py`
Should show >= 25 uses of error_with_recovery.

Run: `python -c "import flash"` (no syntax errors)
  </verify>
  <done>flash.py uses error_with_recovery() for all substantive errors (25+ paths), simple user-input errors remain as out.error()</done>
</task>

</tasks>

<verification>
1. All ERROR_TEMPLATES have numbered recovery steps
2. flash.py imports ERROR_TEMPLATES from errors
3. >= 25 out.error_with_recovery() calls in flash.py
4. No Python syntax errors
5. Error output fits 80 columns (test with long device name)
</verification>

<success_criteria>
- ERROR_TEMPLATES recovery text uses numbered format (1., 2., 3.)
- flash.py error paths use error_with_recovery() with context and recovery
- Simple errors (user input, missing TTY) remain as out.error()
- Python imports work: `python -c "import flash; from errors import ERROR_TEMPLATES"`
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-04-SUMMARY.md`
</output>
