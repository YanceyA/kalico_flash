---
phase: 04-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kalico-flash/errors.py
  - kalico-flash/output.py
autonomous: true

must_haves:
  truths:
    - "All error messages include context (device name, MCU type, path)"
    - "Error messages fit 80-column terminal"
    - "Recovery guidance is prose paragraphs with inline diagnostic commands"
    - "No ANSI colors or Unicode box-drawing in error output"
  artifacts:
    - path: "kalico-flash/errors.py"
      provides: "Exception classes with context attributes and recovery guidance"
      contains: "format_error"
    - path: "kalico-flash/output.py"
      provides: "error_with_recovery method on Output protocol"
      contains: "error_with_recovery"
  key_links:
    - from: "kalico-flash/output.py"
      to: "kalico-flash/errors.py"
      via: "textwrap import for 80-column formatting"
      pattern: "textwrap"
---

<objective>
Create standardized error message framework with context and recovery guidance.

Purpose: All error paths in kalico-flash should provide actionable guidance. This framework establishes the error formatting infrastructure that skip-menuconfig and device exclusion features will use.

Output: Enhanced errors.py with format_error() utility, enhanced Output protocol with error_with_recovery() method.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-foundation/04-CONTEXT.md
@.planning/phases/04-foundation/04-RESEARCH.md
@kalico-flash/errors.py
@kalico-flash/output.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error formatting utilities to errors.py</name>
  <files>kalico-flash/errors.py</files>
  <action>
Add a format_error() function that produces standardized error output:

1. Import textwrap at top of file

2. Create format_error() function with signature:
   ```python
   def format_error(
       error_type: str,
       message: str,
       context: dict[str, str] | None = None,
       recovery: str | None = None,
   ) -> str:
   ```

3. Output format (plain ASCII, no color, 80-column max):
   ```
   [FAIL] {error_type}: {message}

   {context as wrapped prose, if provided}

   {recovery as wrapped prose, if provided}
   ```

4. Use textwrap.fill(text, width=80) for context and recovery prose

5. Context dict should be formatted as natural prose, e.g., {"device": "octopus-pro", "mcu": "stm32h723"} becomes "The device 'octopus-pro' with MCU 'stm32h723'..."

6. Add ERROR_TEMPLATES dict with templates for each error category from ERR-06:
   - Build errors
   - Device not found errors
   - Moonraker errors (placeholder for Phase 5)
   - MCU mismatch errors
   - Service control errors
   - Flash errors

Each template should have: error_type, message_template, recovery_template

Per CONTEXT.md: Recovery steps as prose paragraphs, diagnostic commands inline as copy-paste snippets (e.g., "Run `ls /dev/serial/by-id/` to see connected devices").
  </action>
  <verify>
Run: python -c "from errors import format_error; print(format_error('Device not found', 'octopus-pro', {'device': 'octopus-pro'}, 'Run --list-devices to see registered devices.'))"

Output should be plain text, under 80 columns per line, no ANSI codes.
  </verify>
  <done>format_error() exists, returns properly formatted multi-line error with context and recovery wrapped to 80 columns</done>
</task>

<task type="auto">
  <name>Task 2: Add error_with_recovery() to Output protocol</name>
  <files>kalico-flash/output.py</files>
  <action>
Extend the Output protocol and CliOutput class:

1. Add to Output protocol:
   ```python
   def error_with_recovery(self, error_type: str, message: str,
                           context: dict[str, str] | None = None,
                           recovery: str | None = None) -> None: ...
   ```

2. Implement in CliOutput:
   - Import format_error from errors module
   - Call format_error() and print result to stderr
   - Signature matches protocol

3. Implement in NullOutput:
   - Empty implementation (pass)

4. Keep existing error() method unchanged for backward compatibility - existing code that just needs simple error messages can continue using it.

Per CONTEXT.md: Plain ASCII only, no ANSI escape codes.
  </action>
  <verify>
Run: python -c "from output import CliOutput; out = CliOutput(); out.error_with_recovery('Device not found', 'octopus-pro', {'device': 'octopus-pro'}, 'Run --list-devices.')"

Should print formatted error to stderr.
  </verify>
  <done>error_with_recovery() method exists on Output protocol, CliOutput, and NullOutput</done>
</task>

<task type="auto">
  <name>Task 3: Add context attributes to exception classes</name>
  <files>kalico-flash/errors.py</files>
  <action>
Enhance exception classes to carry context for error formatting:

1. Update DeviceNotFoundError:
   ```python
   class DeviceNotFoundError(KlipperFlashError):
       def __init__(self, identifier: str, *, connected: bool = False):
           super().__init__(f"Device not found: {identifier}")
           self.identifier = identifier
           self.connected = connected  # True if in registry but not connected
   ```

2. Add ConfigMismatchError (new exception for MCU mismatch):
   ```python
   class ConfigMismatchError(KlipperFlashError):
       def __init__(self, expected_mcu: str, actual_mcu: str, device_key: str):
           super().__init__(f"MCU mismatch for {device_key}: expected {expected_mcu}, got {actual_mcu}")
           self.expected_mcu = expected_mcu
           self.actual_mcu = actual_mcu
           self.device_key = device_key
   ```

3. Add ExcludedDeviceError (new exception for device exclusion):
   ```python
   class ExcludedDeviceError(KlipperFlashError):
       def __init__(self, device_key: str):
           super().__init__(f"Device '{device_key}' is excluded from flashing")
           self.device_key = device_key
   ```

4. Ensure all exceptions inherit from KlipperFlashError for consistent handling in flash.py main().
  </action>
  <verify>
Run: python -c "from errors import DeviceNotFoundError, ConfigMismatchError, ExcludedDeviceError; e = ConfigMismatchError('stm32h723', 'rp2040', 'test'); print(e.expected_mcu, e.actual_mcu)"

Should print: stm32h723 rp2040
  </verify>
  <done>DeviceNotFoundError has connected attribute, ConfigMismatchError and ExcludedDeviceError classes exist with context attributes</done>
</task>

</tasks>

<verification>
1. Run Python syntax check: `python -m py_compile kalico-flash/errors.py kalico-flash/output.py`
2. Import test: `python -c "from errors import format_error, ERROR_TEMPLATES, ConfigMismatchError, ExcludedDeviceError; from output import CliOutput"`
3. Format test: `python -c "from errors import format_error; msg = format_error('Test', 'message', {'key': 'value'}, 'Recovery text that is quite long and should wrap properly to fit within eighty columns of terminal width.'); print(msg); assert all(len(line) <= 80 for line in msg.split('\n'))"`
</verification>

<success_criteria>
- format_error() produces 80-column wrapped output
- ERROR_TEMPLATES dict contains templates for all 6 error categories
- Output protocol has error_with_recovery() method
- ConfigMismatchError and ExcludedDeviceError exception classes exist
- All code passes Python syntax check
- No ANSI colors or Unicode in output
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-01-SUMMARY.md`
</output>
