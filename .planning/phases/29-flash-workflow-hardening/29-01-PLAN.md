---
phase: 29-flash-workflow-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kflash/models.py
  - kflash/build.py
  - kflash/flash.py
autonomous: true

must_haves:
  truths:
    - "Single-device flash warns and requires confirmation when USB-derived MCU does not match registry entry"
    - "Flash All skips a device and reports it when USB-derived MCU does not match registry entry"
    - "MCU cross-check is skipped gracefully when extraction returns None"
    - "Flash All shows last 20 lines of build output inline when a build fails"
    - "Full build output is stored in BuildResult.error_output"
  artifacts:
    - path: "kflash/models.py"
      provides: "BuildResult.error_output and BatchDeviceResult.error_output fields"
      contains: "error_output"
    - path: "kflash/build.py"
      provides: "Build output capture when quiet=True and build fails"
      contains: "error_output"
    - path: "kflash/flash.py"
      provides: "MCU cross-check in cmd_flash and cmd_flash_all, build error display in summary"
      contains: "extract_mcu_from_serial"
  key_links:
    - from: "kflash/flash.py"
      to: "kflash/discovery.py"
      via: "extract_mcu_from_serial call in cmd_flash and cmd_flash_all"
      pattern: "extract_mcu_from_serial"
    - from: "kflash/build.py"
      to: "kflash/models.py"
      via: "BuildResult.error_output populated on failure"
      pattern: "error_output"
    - from: "kflash/flash.py"
      to: "kflash/models.py"
      via: "BatchDeviceResult.error_output used in summary"
      pattern: "error_output"
---

<objective>
Add MCU cross-check before flashing (SAFE-03) and build failure output capture for Flash All (DBUG-01).

Purpose: Prevent flashing wrong firmware to a board by detecting MCU mismatches between USB device identity and registry, and make build failures diagnosable by showing output inline.
Output: Modified models.py, build.py, and flash.py with cross-check logic and output capture.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@kflash/models.py
@kflash/build.py
@kflash/flash.py
@kflash/discovery.py (for extract_mcu_from_serial signature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error_output fields and build output capture</name>
  <files>kflash/models.py, kflash/build.py</files>
  <action>
  1. In `kflash/models.py`, add `error_output: Optional[str] = None` field to `BuildResult` (after `error_message`).
  2. In `kflash/models.py`, add `error_output: Optional[str] = None` field to `BatchDeviceResult` (after `error_message`).
  3. In `kflash/build.py`, in `run_build()`, when `quiet=True` and the build fails (returncode != 0), capture the combined stdout+stderr from the subprocess result. The `subprocess.run(..., capture_output=True)` already captures it when `quiet=True`. Decode the output with `.decode('utf-8', errors='replace')`. Store the last 200 lines in `BuildResult.error_output`. Do this for both the `make clean` failure path and the `make -j` failure path. Also do it for timeout failures when quiet=True (the TimeoutExpired exception has `.stdout` and `.stderr` attributes).

  Key details:
  - `capture_output=quiet` is already the pattern used -- when quiet=True, subprocess captures output
  - Access `build_result.stderr` and `build_result.stdout` (bytes) from the CompletedProcess
  - Combine: `output = (build_result.stdout or b"") + (build_result.stderr or b"")`
  - Decode: `output.decode('utf-8', errors='replace')`
  - Cap at last 200 lines: `'\n'.join(lines[-200:])`
  </action>
  <verify>
  Run `python -c "from kflash.models import BuildResult, BatchDeviceResult; r = BuildResult(success=False, error_output='test'); b = BatchDeviceResult(device_key='x', device_name='x', error_output='test'); print('OK')"` on Pi via SSH.
  </verify>
  <done>BuildResult and BatchDeviceResult have error_output fields. run_build() populates error_output from captured subprocess output on failure when quiet=True.</done>
</task>

<task type="auto">
  <name>Task 2: MCU cross-check in flash workflows and build error display in Flash All</name>
  <files>kflash/flash.py</files>
  <action>
  **SAFE-03a: MCU cross-check in cmd_flash (single-device)**

  After the device path is resolved (after the `device_path = usb_device.path` assignment, around line 631), before preflight:
  1. Import `extract_mcu_from_serial` from `.discovery` (add to existing import block around line 350-356).
  2. Call `usb_mcu = extract_mcu_from_serial(usb_device.filename)`.
  3. If `usb_mcu is not None` and `usb_mcu.lower() != entry.mcu.lower()`:
     - `out.warn(f"MCU mismatch: USB device reports '{usb_mcu}' but registry has '{entry.mcu}'")`
     - `if not out.confirm("Continue with flash anyway?", default=False):` return 0
  4. If `usb_mcu is None`: do nothing (best-effort, skip check silently).

  **SAFE-03b: MCU cross-check in cmd_flash_all (batch)**

  In `cmd_flash_all`, inside the Stage 4 flash loop, after `usb_device = match_device(...)` succeeds and after the duplicate path guard (around line 1254), before determining flash method:
  1. Import `extract_mcu_from_serial` from `.discovery` (add to existing import block around line 986).
  2. Call `usb_mcu = extract_mcu_from_serial(usb_device.filename)`.
  3. If `usb_mcu is not None` and `usb_mcu.lower() != entry.mcu.lower()`:
     - `result.error_message = f"MCU mismatch: USB='{usb_mcu}', registry='{entry.mcu}'"`
     - `out.warn(f"Skipping {entry.name}: {result.error_message}")`
     - `continue` (skip this device)
  4. If `usb_mcu is None`: proceed normally (best-effort).

  **DBUG-01: Build error output in Flash All summary**

  In the Stage 3 build loop (around line 1198-1211):
  1. After `build_result = run_build(klipper_dir, quiet=True)`, on failure path:
     - Store `result.error_output = build_result.error_output`

  In the Stage 5 summary (around line 1301-1329):
  1. After printing each failed result row, if `result.error_output` is not None:
     - `lines = result.error_output.strip().splitlines()`
     - `tail = lines[-20:]` (last 20 lines)
     - `out.info("", f"  Build output (last {len(tail)} lines):")`
     - For each line in tail: `out.info("", f"    {line}")`
  </action>
  <verify>
  1. `python -c "from kflash.flash import cmd_flash, cmd_flash_all; print('imports OK')"` on Pi via SSH.
  2. Visually inspect: grep for `extract_mcu_from_serial` in flash.py -- should appear in both cmd_flash and cmd_flash_all.
  3. Grep for `error_output` in flash.py -- should appear in build failure handling and summary display.
  </verify>
  <done>
  - cmd_flash warns and prompts on MCU mismatch, skips check when None
  - cmd_flash_all skips device on MCU mismatch, skips check when None
  - Flash All stores build error_output and displays last 20 lines inline for failed builds
  </done>
</task>

</tasks>

<verification>
1. SCP files to Pi and run `python3 -c "from kflash import flash; print('OK')"` -- no import errors
2. Grep `extract_mcu_from_serial` in flash.py -- appears in cmd_flash discovery section AND cmd_flash_all Stage 4
3. Grep `error_output` in models.py -- appears in both BuildResult and BatchDeviceResult
4. Grep `error_output` in build.py -- populated on build failure when quiet=True
5. Grep `error_output` in flash.py -- stored from build_result and displayed in summary
6. Manual test on Pi: Flash a device -- MCU check should pass silently (matching MCU)
</verification>

<success_criteria>
- BuildResult and BatchDeviceResult both have error_output: Optional[str] = None
- run_build() captures and stores output on failure when quiet=True
- cmd_flash calls extract_mcu_from_serial and warns+confirms on mismatch
- cmd_flash_all calls extract_mcu_from_serial and skips+reports on mismatch
- Both functions skip the check gracefully when extraction returns None
- Flash All summary shows last 20 lines of build output for failed builds
- All imports resolve without errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-flash-workflow-hardening/29-01-SUMMARY.md`
</output>
