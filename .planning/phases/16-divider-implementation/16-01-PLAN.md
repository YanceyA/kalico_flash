---
phase: 16-divider-implementation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kflash/ansi.py
  - kflash/panels.py
  - kflash/output.py
autonomous: true

must_haves:
  truths:
    - "Output Protocol defines step_divider() and device_divider() methods"
    - "CliOutput renders unlabeled step divider using ┄ in border color (muted teal)"
    - "CliOutput renders labeled device divider as ─── 1/N Name ─── in border color"
    - "NullOutput implements both divider methods as no-ops"
    - "Divider width adapts to terminal width via get_terminal_width()"
    - "Dividers degrade to ASCII dashes on non-Unicode terminals"
  artifacts:
    - path: "kflash/ansi.py"
      provides: "supports_unicode() detection function"
      contains: "def supports_unicode"
    - path: "kflash/panels.py"
      provides: "render_step_divider and render_device_divider functions"
      contains: "def render_device_divider"
    - path: "kflash/output.py"
      provides: "step_divider and device_divider on Protocol, CliOutput, NullOutput"
      contains: "def step_divider"
  key_links:
    - from: "kflash/output.py"
      to: "kflash/panels.py"
      via: "CliOutput.step_divider calls render functions"
      pattern: "from .panels import"
    - from: "kflash/panels.py"
      to: "kflash/ansi.py"
      via: "render functions use supports_unicode and get_terminal_width"
      pattern: "supports_unicode"
---

<objective>
Add step_divider() and device_divider() methods to the Output Protocol and implement them with theme-aware rendering, dynamic terminal width, and ASCII fallback.

Purpose: Provide visual separation primitives that Phase 17 will wire into all command workflows.
Output: Three modified files (ansi.py, panels.py, output.py) with complete divider rendering pipeline.
</objective>

<context>
@.planning/phases/16-divider-implementation/16-RESEARCH.md
@kflash/ansi.py
@kflash/panels.py
@kflash/output.py
@kflash/theme.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add supports_unicode() and update panel render functions</name>
  <files>kflash/ansi.py, kflash/panels.py</files>
  <action>
  **In kflash/ansi.py:** Add a `supports_unicode()` function after `get_terminal_width()`:

  ```python
  def supports_unicode() -> bool:
      """Check if stdout encoding supports Unicode box-drawing characters."""
      encoding = getattr(sys.stdout, 'encoding', '') or ''
      return 'utf' in encoding.lower()
  ```

  Note: `sys` is not currently imported in ansi.py. Add `import sys` at the top with the other imports.

  **In kflash/panels.py:** Make two changes:

  1. Update the import line to include `supports_unicode`:
     `from kflash.ansi import display_width, get_terminal_width, pad_to_width, strip_ansi, supports_unicode`

  2. Modify `render_step_divider()` to:
     - Change default `total_width` parameter from `60` to `None`
     - When `total_width is None`, set it to `get_terminal_width()`
     - Change color from `theme.subtle` to `theme.border` for the dashes
     - Use `supports_unicode()` to choose between `\u2504` (┄) and `-` for the dash character

  3. Modify `render_action_divider()` to:
     - Remove hardcoded `width = 60`, use `get_terminal_width()` instead
     - Change color from `theme.subtle` to `theme.border`
     - Use `supports_unicode()` for dash character selection

  4. Add new `render_device_divider()` function after `render_action_divider()`:

  ```python
  def render_device_divider(index: int, total: int, name: str, total_width: int | None = None) -> str:
      """Render a labeled device divider: ─── 1/3 DeviceName ───

      Args:
          index: 1-based device index.
          total: Total number of devices.
          name: Device display name.
          total_width: Override width (auto-detected if None).

      Returns:
          Single formatted line.
      """
      theme = get_theme()
      if total_width is None:
          total_width = get_terminal_width()
      dash = "\u2500" if supports_unicode() else "-"  # ─ or -
      label = f" {index}/{total} {name} "
      label_width = len(label)
      side_left = (total_width - label_width) // 2
      if side_left < 0:
          side_left = 0
      side_right = total_width - label_width - side_left
      if side_right < 0:
          side_right = 0
      return (
          f"{theme.border}{dash * side_left}{theme.reset}"
          f"{theme.border}{label}{theme.reset}"
          f"{theme.border}{dash * side_right}{theme.reset}"
      )
  ```
  </action>
  <verify>
  Run `python -c "from kflash.ansi import supports_unicode; print(supports_unicode())"` to confirm the function exists and returns True/False.
  Run `python -c "from kflash.panels import render_device_divider; print(repr(render_device_divider(1, 3, 'Octopus Pro')))"` to confirm it produces output.
  Run `python -c "from kflash.panels import render_step_divider; print(repr(render_step_divider('test')))"` to confirm dynamic width works.
  </verify>
  <done>
  - `supports_unicode()` exists in ansi.py and returns bool based on stdout encoding
  - `render_step_divider()` uses border color and dynamic width (no hardcoded 60)
  - `render_action_divider()` uses border color and dynamic width
  - `render_device_divider()` produces centered `─── 1/N Name ───` format in border color
  - All render functions fall back to ASCII `-` when `supports_unicode()` returns False
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Output Protocol with divider methods</name>
  <files>kflash/output.py</files>
  <action>
  Add two methods to each of the three classes in output.py:

  **1. Output Protocol class** — add after the `phase` method:
  ```python
  def step_divider(self) -> None: ...
  def device_divider(self, index: int, total: int, name: str) -> None: ...
  ```

  **2. CliOutput class** — add after the `phase` method:
  ```python
  def step_divider(self) -> None:
      """Print an unlabeled step divider line."""
      from .panels import render_action_divider
      print(render_action_divider())

  def device_divider(self, index: int, total: int, name: str) -> None:
      """Print a labeled device divider for batch operations."""
      from .panels import render_device_divider
      print(render_device_divider(index, total, name))
  ```

  **3. NullOutput class** — add after the `phase` method:
  ```python
  def step_divider(self) -> None:
      pass

  def device_divider(self, index: int, total: int, name: str) -> None:
      pass
  ```

  Note: Use late imports in CliOutput (matching existing pattern from `error_with_recovery`).
  </action>
  <verify>
  Run `python -c "from kflash.output import CliOutput, NullOutput; c = CliOutput(); c.step_divider(); c.device_divider(1, 3, 'Test')"` to confirm both methods work.
  Run `python -c "from kflash.output import NullOutput; n = NullOutput(); n.step_divider(); n.device_divider(1, 2, 'X')"` to confirm no-ops work silently.
  </verify>
  <done>
  - Output Protocol has `step_divider()` and `device_divider(index, total, name)` method signatures
  - CliOutput implements both methods, delegating to panels.py render functions
  - NullOutput implements both methods as `pass` stubs
  - No circular imports introduced
  </done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from kflash.output import Output, CliOutput, NullOutput"` succeeds
2. Protocol compliance: CliOutput and NullOutput both have `step_divider` and `device_divider` attributes
3. Visual check: `python -c "from kflash.output import CliOutput; o = CliOutput(); o.step_divider(); o.device_divider(2, 5, 'Octopus Pro')"` renders two divider lines
4. ASCII fallback: With `PYTHONIOENCODING=ascii`, dividers use `-` instead of Unicode
5. Dynamic width: Dividers span terminal width, not hardcoded 60 or 80
</verification>

<success_criteria>
- Output Protocol defines step_divider() and device_divider() methods
- CliOutput renders step divider as ┄ line in border color (muted teal)
- CliOutput renders device divider as ─── 1/N Name ─── in border color
- NullOutput implements both as no-ops
- Dividers adapt to terminal width
- ASCII fallback works on non-Unicode terminals
</success_criteria>

<output>
After completion, create `.planning/phases/16-divider-implementation/16-01-SUMMARY.md`
</output>
