---
phase: 09-apply-theming
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - kflash/output.py
  - kflash/tui.py
  - kflash/errors.py
autonomous: true

must_haves:
  truths:
    - "CLI messages show colored brackets ([OK] green, [FAIL] red, etc.)"
    - "Device markers show distinct colors by type"
    - "Menu clears screen before display"
    - "Menu title displays bold"
    - "Error messages show red [FAIL] header"
    - "Prompts display in bold"
  artifacts:
    - path: "kflash/output.py"
      provides: "Themed CLI output methods"
      contains: "get_theme"
    - path: "kflash/tui.py"
      provides: "Screen clear and styled menu"
      contains: "clear_screen"
    - path: "kflash/errors.py"
      provides: "Themed error formatting"
      contains: "get_theme"
  key_links:
    - from: "kflash/output.py"
      to: "kflash/theme.py"
      via: "get_theme import"
      pattern: "from \\.theme import get_theme"
    - from: "kflash/tui.py"
      to: "kflash/theme.py"
      via: "clear_screen import"
      pattern: "from \\.theme import.*clear_screen"
    - from: "kflash/errors.py"
      to: "kflash/theme.py"
      via: "get_theme import"
      pattern: "from \\.theme import get_theme"
---

<objective>
Apply theme styling to output messages, TUI menus, and error formatting.

Purpose: Integrate the theme.py infrastructure across the CLI to provide KIAUH-style colored output. This completes the v2.1 color theme milestone.

Output: Colored CLI output with styled brackets, device markers, menu titles, and error headers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-apply-theming/09-CONTEXT.md
@.planning/phases/09-apply-theming/09-RESEARCH.md
@.planning/phases/09-apply-theming/09-01-SUMMARY.md
@kflash/theme.py
@kflash/output.py
@kflash/tui.py
@kflash/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply theming to output.py</name>
  <files>kflash/output.py</files>
  <action>
Update CliOutput class to use themed output:

1. Add import at top:
   ```python
   from .theme import get_theme
   ```

2. Add theme initialization in CliOutput.__init__():
   ```python
   def __init__(self) -> None:
       self.theme = get_theme()
   ```

3. Update each method to use themed brackets (color bracket only, not message):

   info():
   ```python
   def info(self, section: str, message: str) -> None:
       t = self.theme
       print(f"{t.info}[{section}]{t.reset} {message}")
   ```

   success():
   ```python
   def success(self, message: str) -> None:
       t = self.theme
       print(f"{t.success}[OK]{t.reset} {message}")
   ```

   warn():
   ```python
   def warn(self, message: str) -> None:
       t = self.theme
       print(f"{t.warning}[!!]{t.reset} {message}")
   ```

   error():
   ```python
   def error(self, message: str) -> None:
       t = self.theme
       print(f"{t.error}[FAIL]{t.reset} {message}", file=sys.stderr)
   ```

   phase():
   ```python
   def phase(self, phase_name: str, message: str) -> None:
       t = self.theme
       print(f"{t.phase}[{phase_name}]{t.reset} {message}")
   ```

   device_line() - use marker style lookup:
   ```python
   def device_line(self, marker: str, name: str, detail: str) -> None:
       t = self.theme
       marker_styles = {
           "REG": t.marker_reg,
           "NEW": t.marker_new,
           "BLK": t.marker_blk,
           "DUP": t.marker_dup,
       }
       style = marker_styles.get(marker.upper(), "")
       print(f"  {style}[{marker}]{t.reset} {name:<24s} {detail}")
   ```

   prompt():
   ```python
   def prompt(self, message: str, default: str = "") -> str:
       t = self.theme
       suffix = f" [{default}]" if default else ""
       response = input(f"{t.prompt}{message}{suffix}:{t.reset} ").strip()
       return response or default
   ```

   confirm():
   ```python
   def confirm(self, message: str, default: bool = False) -> bool:
       t = self.theme
       suffix = " [Y/n]" if default else " [y/N]"
       response = input(f"{t.prompt}{message}{suffix}:{t.reset} ").strip().lower()
       if not response:
           return default
       return response in ("y", "yes")
   ```

Note: NullOutput class does not need changes (no output = no styling needed).
  </action>
  <verify>
```bash
python -m py_compile kflash/output.py
python -c "from kflash.output import CliOutput; o = CliOutput(); o.success('test')"
```
  </verify>
  <done>
- CliOutput imports get_theme
- CliOutput.__init__ stores self.theme
- All output methods use themed brackets
- Device markers use style lookup dict
- Prompts display in bold
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply theming to tui.py</name>
  <files>kflash/tui.py</files>
  <action>
Update TUI module with screen clear and styled menu:

1. Add imports at top (after existing imports):
   ```python
   from .theme import get_theme, clear_screen
   ```

2. Add clear_screen() at start of run_menu() while loop (line ~187):
   ```python
   while True:
       try:
           clear_screen()  # Add this line
           print()
           print(menu_text)
           ...
   ```

3. Add clear_screen() at start of _settings_menu() while loop (line ~311):
   ```python
   while True:
       clear_screen()  # Add this line
       print()
       print(settings_text)
       ...
   ```

4. Update _render_menu() to style the title (keep width calculation using plain text):
   ```python
   def _render_menu(options: list[tuple[str, str]], box: dict[str, str]) -> str:
       theme = get_theme()  # Add at function start

       # ... existing width calculations ...

       # Calculate title width using PLAIN text
       title_plain = "kalico-flash"
       title_width = len(title_plain) + 2  # +2 for spaces
       inner_width = max(inner_width, title_width)

       # Create styled title for display
       title_display = f" {theme.menu_title}{title_plain}{theme.reset} "

       lines: list[str] = []

       # Top border with styled title
       pad_total = inner_width - title_width
       pad_left = pad_total // 2
       pad_right = pad_total - pad_left
       lines.append(
           box["tl"] + box["h"] * pad_left + title_display + box["h"] * pad_right + box["tr"]
       )
       # ... rest unchanged ...
   ```

5. Add pause_with_keypress() utility function (after _supports_unicode, before MENU_OPTIONS):
   ```python
   def pause_with_keypress(timeout: float = 5.0, prompt: str = "") -> bool:
       """Wait for keypress or timeout. Returns True if key pressed.

       Unix-only implementation using select + termios.
       On Windows or non-TTY, falls back to time.sleep().
       """
       import time

       if not sys.stdin.isatty():
           time.sleep(timeout)
           return False

       if prompt:
           print(prompt, end="", flush=True)

       # Unix: use select + termios for non-blocking input
       if sys.platform != "win32":
           try:
               import select
               import termios
               import tty

               fd = sys.stdin.fileno()
               old_settings = termios.tcgetattr(fd)
               try:
                   tty.setcbreak(fd)
                   rlist, _, _ = select.select([sys.stdin], [], [], timeout)
                   if rlist:
                       sys.stdin.read(1)  # Consume keypress
                       return True
                   return False
               finally:
                   termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
           except Exception:
               pass  # Fall through to sleep

       # Windows or fallback: simple sleep
       time.sleep(timeout)
       return False
   ```

Note: pause_with_keypress is defined but not yet called - future actions will use it for feedback pauses. This prepares the infrastructure.
  </action>
  <verify>
```bash
python -m py_compile kflash/tui.py
python -c "from kflash.tui import pause_with_keypress; print('pause function exists')"
```
  </verify>
  <done>
- tui.py imports get_theme and clear_screen
- run_menu() calls clear_screen() at loop start
- _settings_menu() calls clear_screen() at loop start
- _render_menu() uses themed title (bold)
- pause_with_keypress() utility available for future use
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply theming to errors.py</name>
  <files>kflash/errors.py</files>
  <action>
Update format_error() to use themed [FAIL] header:

1. Add import at top (after existing imports):
   ```python
   from .theme import get_theme
   ```

2. Update format_error() to style the header:
   ```python
   def format_error(
       error_type: str,
       message: str,
       context: dict[str, str] | None = None,
       recovery: str | None = None,
   ) -> str:
       """..."""
       t = get_theme()
       lines = [f"{t.error}[FAIL]{t.reset} {error_type}: {message}"]
       # ... rest unchanged ...
   ```

Only the [FAIL] bracket is colored. The error_type, message, context, and recovery remain uncolored for readability per CONTEXT.md decision.
  </action>
  <verify>
```bash
python -m py_compile kflash/errors.py
python -c "from kflash.errors import format_error; print(format_error('Test', 'message'))"
```
  </verify>
  <done>
- errors.py imports get_theme
- format_error() uses themed [FAIL] header
- Rest of error message remains uncolored for readability
  </done>
</task>

</tasks>

<verification>
Visual verification on Pi (SSH with color support):
1. `kflash --list-devices` - colored markers (green REG, yellow NEW/BLK)
2. `kflash` - screen clears, bold title in menu box
3. `kflash --device nonexistent` - red [FAIL] header in error
4. `NO_COLOR=1 kflash --list-devices` - no colors (fallback works)

Syntax verification:
```bash
python -m py_compile kflash/output.py kflash/tui.py kflash/errors.py
```
</verification>

<success_criteria>
- All three files compile without errors
- CliOutput methods produce colored bracket output
- Menu clears screen before display
- Menu title is bold
- Error [FAIL] header is red
- NO_COLOR=1 disables all styling
</success_criteria>

<output>
After completion, create `.planning/phases/09-apply-theming/09-02-SUMMARY.md`
</output>
