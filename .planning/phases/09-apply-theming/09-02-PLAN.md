---
phase: 09-apply-theming
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - kflash/output.py
  - kflash/tui.py
  - kflash/errors.py
autonomous: true

must_haves:
  truths:
    - "CLI messages show colored brackets ([OK] green, [FAIL] red, etc.)"
    - "Device markers show distinct colors by type"
    - "Menu clears screen before display"
    - "Menu title displays bold"
    - "Error messages show red [FAIL] header"
    - "Prompts display in bold"
    - "NO_COLOR=1 disables all styling (fallback works)"
  artifacts:
    - path: "kflash/output.py"
      provides: "Themed CLI output methods"
      contains: "get_theme"
    - path: "kflash/tui.py"
      provides: "Screen clear and styled menu"
      contains: "clear_screen"
    - path: "kflash/errors.py"
      provides: "Themed error formatting"
      contains: "get_theme"
  key_links:
    - from: "kflash/output.py"
      to: "kflash/theme.py"
      via: "get_theme import"
      pattern: "from \\.theme import get_theme"
    - from: "kflash/tui.py"
      to: "kflash/theme.py"
      via: "clear_screen import"
      pattern: "from \\.theme import.*clear_screen"
    - from: "kflash/errors.py"
      to: "kflash/theme.py"
      via: "get_theme import"
      pattern: "from \\.theme import get_theme"
---

<objective>
Apply theme styling to output messages, TUI menus, and error formatting.

Purpose: Integrate the theme.py infrastructure across the CLI to provide KIAUH-style colored output. This completes the v2.1 color theme milestone.

Output: Colored CLI output with styled brackets, device markers, menu titles, and error headers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-apply-theming/09-CONTEXT.md
@.planning/phases/09-apply-theming/09-RESEARCH.md
@.planning/phases/09-apply-theming/09-01-SUMMARY.md
@kflash/theme.py
@kflash/output.py
@kflash/tui.py
@kflash/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply theming to output.py</name>
  <files>kflash/output.py</files>
  <action>
Update CliOutput class to use themed output. Use consistent pattern: store theme in __init__, use local variable `t = self.theme` at method start for concise access.

1. Add import at top:
   ```python
   from .theme import get_theme
   ```

2. Add theme initialization in CliOutput.__init__():
   ```python
   def __init__(self) -> None:
       self.theme = get_theme()
   ```

3. Update each method to use themed brackets (color bracket only, not message). Use consistent pattern: `t = self.theme` at method start.

   info():
   ```python
   def info(self, section: str, message: str) -> None:
       t = self.theme
       print(f"{t.info}[{section}]{t.reset} {message}")
   ```

   success():
   ```python
   def success(self, message: str) -> None:
       t = self.theme
       print(f"{t.success}[OK]{t.reset} {message}")
   ```

   warn():
   ```python
   def warn(self, message: str) -> None:
       t = self.theme
       print(f"{t.warning}[!!]{t.reset} {message}")
   ```

   error():
   ```python
   def error(self, message: str) -> None:
       t = self.theme
       print(f"{t.error}[FAIL]{t.reset} {message}", file=sys.stderr)
   ```

   phase():
   ```python
   def phase(self, phase_name: str, message: str) -> None:
       t = self.theme
       print(f"{t.phase}[{phase_name}]{t.reset} {message}")
   ```

   device_line() - use marker style lookup with ALL marker types including marker_num:
   ```python
   def device_line(self, marker: str, name: str, detail: str) -> None:
       t = self.theme
       marker_styles = {
           "REG": t.marker_reg,
           "NEW": t.marker_new,
           "BLK": t.marker_blk,
           "DUP": t.marker_dup,
       }
       # For numbered markers (1, 2, 3...), use marker_num style
       if marker.isdigit():
           style = t.marker_num
       else:
           style = marker_styles.get(marker.upper(), "")
       print(f"  {style}[{marker}]{t.reset} {name:<24s} {detail}")
   ```

   prompt():
   ```python
   def prompt(self, message: str, default: str = "") -> str:
       t = self.theme
       suffix = f" [{default}]" if default else ""
       response = input(f"{t.prompt}{message}{suffix}:{t.reset} ").strip()
       return response or default
   ```

   confirm():
   ```python
   def confirm(self, message: str, default: bool = False) -> bool:
       t = self.theme
       suffix = " [Y/n]" if default else " [y/N]"
       response = input(f"{t.prompt}{message}{suffix}:{t.reset} ").strip().lower()
       if not response:
           return default
       return response in ("y", "yes")
   ```

Note: NullOutput class does not need changes (no output = no styling needed).
  </action>
  <verify>
```bash
python -m py_compile kflash/output.py
python -c "from kflash.output import CliOutput; o = CliOutput(); o.success('test')"
```
  </verify>
  <done>
- CliOutput imports get_theme
- CliOutput.__init__ stores self.theme
- All output methods use `t = self.theme` pattern consistently
- Device markers use style lookup dict with marker_num for numbered markers
- Prompts display in bold
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply theming to tui.py (screen clear and menu styling)</name>
  <files>kflash/tui.py</files>
  <action>
Update TUI module with screen clear and styled menu. Note: pause_with_keypress is deferred to a future phase since the CONTEXT.md pause behavior (feedback pauses after success/error) requires integration points that span multiple modules.

1. Add imports at top (after existing imports):
   ```python
   from .theme import get_theme, clear_screen
   ```

2. Add clear_screen() at start of run_menu() while loop (line ~187):
   ```python
   while True:
       try:
           clear_screen()  # Add this line
           print()
           print(menu_text)
           ...
   ```

3. Add clear_screen() at start of _settings_menu() while loop (line ~311):
   ```python
   while True:
       clear_screen()  # Add this line
       print()
       print(settings_text)
       ...
   ```

4. Update _render_menu() to style the title (keep width calculation using plain text):
   ```python
   def _render_menu(options: list[tuple[str, str]], box: dict[str, str]) -> str:
       theme = get_theme()  # Add at function start

       # ... existing width calculations ...

       # Calculate title width using PLAIN text
       title_plain = "kalico-flash"
       title_width = len(title_plain) + 2  # +2 for spaces
       inner_width = max(inner_width, title_width)

       # Create styled title for display
       title_display = f" {theme.menu_title}{title_plain}{theme.reset} "

       lines: list[str] = []

       # Top border with styled title
       pad_total = inner_width - title_width
       pad_left = pad_total // 2
       pad_right = pad_total - pad_left
       lines.append(
           box["tl"] + box["h"] * pad_left + title_display + box["h"] * pad_right + box["tr"]
       )
       # ... rest unchanged ...
   ```

Note: pause_with_keypress() implementation deferred. CONTEXT.md specifies "After success/error outcomes: Show feedback, then pause" which requires orchestration between output.py and tui.py beyond this phase's scope.
  </action>
  <verify>
```bash
python -m py_compile kflash/tui.py
python -c "from kflash.tui import clear_screen; print('clear_screen imported successfully')"
```
  </verify>
  <done>
- tui.py imports get_theme and clear_screen
- run_menu() calls clear_screen() at loop start
- _settings_menu() calls clear_screen() at loop start
- _render_menu() uses themed title (bold)
  </done>
</task>

<task type="auto">
  <name>Task 3: Apply theming to errors.py</name>
  <files>kflash/errors.py</files>
  <action>
Update format_error() to use themed [FAIL] header:

1. Add import at top (after existing imports):
   ```python
   from .theme import get_theme
   ```

2. Update format_error() to style the header:
   ```python
   def format_error(
       error_type: str,
       message: str,
       context: dict[str, str] | None = None,
       recovery: str | None = None,
   ) -> str:
       """..."""
       t = get_theme()
       lines = [f"{t.error}[FAIL]{t.reset} {error_type}: {message}"]
       # ... rest unchanged ...
   ```

Only the [FAIL] bracket is colored. The error_type, message, context, and recovery remain uncolored for readability per CONTEXT.md decision.
  </action>
  <verify>
```bash
python -m py_compile kflash/errors.py
python -c "from kflash.errors import format_error; print(format_error('Test', 'message'))"
```
  </verify>
  <done>
- errors.py imports get_theme
- format_error() uses themed [FAIL] header
- Rest of error message remains uncolored for readability
  </done>
</task>

</tasks>

<verification>
Visual verification on Pi (SSH with color support):
1. `kflash --list-devices` - colored markers (green REG, yellow NEW/BLK)
2. `kflash` - screen clears, bold title in menu box
3. `kflash --device nonexistent` - red [FAIL] header in error
4. `NO_COLOR=1 kflash --list-devices` - no colors (fallback works)

Syntax verification:
```bash
python -m py_compile kflash/output.py kflash/tui.py kflash/errors.py
```
</verification>

<success_criteria>
- All three files compile without errors
- CliOutput methods produce colored bracket output
- Menu clears screen before display
- Menu title is bold
- Error [FAIL] header is red
- NO_COLOR=1 disables all styling
</success_criteria>

<output>
After completion, create `.planning/phases/09-apply-theming/09-02-SUMMARY.md`
</output>
