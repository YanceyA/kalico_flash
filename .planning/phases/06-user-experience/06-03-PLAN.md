---
phase: 06-user-experience
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - kalico-flash/tui.py
  - kalico-flash/flash.py
  - kalico-flash/errors.py
autonomous: true

must_haves:
  truths:
    - "User sees 'Verifying....' with dots during post-flash wait"
    - "User sees device path after successful flash verification"
    - "User sees recovery steps if device does not reappear within 30 seconds"
    - "User sees failure message if device reappears as katapult_ instead of Klipper_"
  artifacts:
    - path: "kalico-flash/tui.py"
      provides: "wait_for_device() polling function"
      exports: ["wait_for_device"]
      min_lines: 180
    - path: "kalico-flash/errors.py"
      provides: "Error template for verification timeout"
      contains: "verification_timeout"
  key_links:
    - from: "kalico-flash/flash.py"
      to: "kalico-flash/tui.py"
      via: "wait_for_device() import and call"
      pattern: "from tui import wait_for_device"
    - from: "kalico-flash/tui.py"
      to: "kalico-flash/discovery.py"
      via: "scan_serial_devices() for polling"
      pattern: "from discovery import scan_serial_devices"
---

<objective>
Add post-flash device verification to flash workflow with polling and progress feedback.

Purpose: Users know whether flash succeeded by seeing device reappear as Klipper_, with recovery guidance if it doesn't.

Output: wait_for_device() function in tui.py, integrated into flash.py after flash_device() call.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-user-experience/06-CONTEXT.md
@.planning/phases/06-user-experience/06-RESEARCH.md
@.planning/phases/06-user-experience/06-01-SUMMARY.md
@.planning/phases/06-user-experience/06-02-SUMMARY.md
@kalico-flash/tui.py
@kalico-flash/flash.py
@kalico-flash/discovery.py
@kalico-flash/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add wait_for_device() polling function to tui.py</name>
  <files>kalico-flash/tui.py</files>
  <action>
Add verification polling function to tui.py:

```python
def wait_for_device(
    serial_pattern: str,
    timeout: float = 30.0,
    interval: float = 0.5,
) -> tuple[bool, str | None, str | None]:
    """Poll for device to reappear after flash.

    Prints progress dots every 2 seconds. Checks both device existence
    AND prefix (Klipper_ expected, katapult_ means failure).

    Args:
        serial_pattern: Glob pattern to match device filename
        timeout: Maximum seconds to wait (per CONTEXT.md: 30s)
        interval: Seconds between polls

    Returns:
        (success, device_path, error_reason)
        - success=True, path="/dev/...", reason=None -> device found with Klipper_ prefix
        - success=False, path="/dev/...", reason="..." -> device found but wrong state
        - success=False, path=None, reason="Timeout..." -> device never appeared
    """
    import time
    import fnmatch
    from discovery import scan_serial_devices

    start = time.monotonic()
    last_dot_time = start

    print("Verifying", end="", flush=True)

    while time.monotonic() - start < timeout:
        # Progress dots every 2 seconds
        now = time.monotonic()
        if now - last_dot_time >= 2.0:
            print(".", end="", flush=True)
            last_dot_time = now

        # Scan for devices
        devices = scan_serial_devices()
        for device in devices:
            if fnmatch.fnmatch(device.filename, serial_pattern):
                print()  # Newline after dots

                if device.filename.startswith("usb-Klipper_"):
                    return (True, device.path, None)
                elif device.filename.startswith("usb-katapult_"):
                    return (False, device.path, "Device in bootloader mode (katapult)")
                else:
                    return (False, device.path, f"Unexpected device prefix: {device.filename}")

        time.sleep(interval)

    print()  # Newline after dots
    return (False, None, f"Timeout after {int(timeout)}s waiting for device")
```

Key points:
- Per CONTEXT.md: 30-second timeout (overrides VERIFY-02's 15s)
- Per CONTEXT.md: "Progress dots feedback while waiting"
- Per CONTEXT.md: "Wrong prefix is failure" - katapult_ treated as failure
- Uses existing scan_serial_devices() from discovery.py
- Returns tuple for easy caller handling

This function is public (exported) so flash.py can import and use it.
  </action>
  <verify>
Syntax check: `python -m py_compile kalico-flash/tui.py`
Import test: `python -c "from tui import wait_for_device; print('OK')"`
  </verify>
  <done>wait_for_device() exists in tui.py with 30s timeout, progress dots, prefix checking</done>
</task>

<task type="auto">
  <name>Task 2: Add verification error template to errors.py</name>
  <files>kalico-flash/errors.py</files>
  <action>
Add error template for verification timeout to ERROR_TEMPLATES dict:

```python
"verification_timeout": {
    "error_type": "Verification failed",
    "message_template": "Device did not reappear after flash",
    "recovery_template": (
        "1. Check USB cable is firmly connected\n"
        "2. Try unplugging and replugging the board\n"
        "3. Check device status: `ls /dev/serial/by-id/`\n"
        "4. Check kernel messages: `dmesg | tail -20`\n"
        "5. Board may need manual bootloader entry (hold BOOT button)"
    ),
},
"verification_wrong_prefix": {
    "error_type": "Verification failed",
    "message_template": "Device reappeared in bootloader mode",
    "recovery_template": (
        "1. Flash may have failed - device is still in bootloader\n"
        "2. Check device: `ls /dev/serial/by-id/ | grep katapult`\n"
        "3. Try flash again - Katapult method should retry\n"
        "4. If repeated failures, check firmware binary exists"
    ),
},
```

Per CONTEXT.md: "Recovery guidance on timeout: physical checks first (check USB, try unplug/replug), then diagnostic commands (`ls /dev/serial/by-id/`, `dmesg | tail`)"

Place these after "flash_failed" template in the dict.
  </action>
  <verify>
Syntax check: `python -m py_compile kalico-flash/errors.py`
Template check: `python -c "from errors import ERROR_TEMPLATES; print('verification_timeout' in ERROR_TEMPLATES)"`
  </verify>
  <done>ERROR_TEMPLATES has verification_timeout and verification_wrong_prefix entries</done>
</task>

<task type="auto">
  <name>Task 3: Integrate verification into flash.py cmd_flash()</name>
  <files>kalico-flash/flash.py</files>
  <action>
Modify cmd_flash() to call wait_for_device() after successful flash.

**Timing clarification:** Verification happens AFTER flash_device() returns but INSIDE the `with klipper_service_stopped():` context manager. This is correct because:
1. Klipper must stay stopped while we wait for device to reboot
2. Device resets after flash and needs time to re-enumerate on USB
3. Once device reappears (or times out), THEN context manager exits and restarts Klipper
4. Klipper restart happens regardless of verification outcome (context manager guarantee)

**Implementation:**

1. **Import wait_for_device at top of function** (with other late imports):
   ```python
   from tui import wait_for_device
   ```

2. **Modify the flash section to include verification inside context manager:**

   ```python
   try:
       with klipper_service_stopped():
           out.phase("Flash", "Flashing firmware...")
           flash_result = flash_device(...)

           if flash_result.success:
               # Verify device reappears BEFORE restarting Klipper
               out.phase("Verify", "Waiting for device to reappear...")
               verified, device_path, error_reason = wait_for_device(
                   entry.serial_pattern,
                   timeout=30.0,
               )
           else:
               # Flash itself failed - no verification needed
               verified = False
               device_path = None
               error_reason = flash_result.error_message

       # Context manager exited - Klipper has restarted
       out.phase("Service", "Klipper restarted")

   except ServiceError as e:
       ...
   ```

3. **After the context manager, handle verification result:**

   ```python
   # === Summary ===
   if flash_result.success and verified:
       out.success(
           f"Flashed {entry.name} via {flash_result.method} in {flash_elapsed:.1f}s"
       )
       out.phase("Verify", f"Device confirmed at: {device_path}")
       return 0

   elif flash_result.success and not verified:
       # Flash appeared to succeed but device didn't reappear correctly
       out.warn(f"Device verification failed: {error_reason}")
       if device_path:
           # Device appeared but wrong state (e.g., still in bootloader)
           template = ERROR_TEMPLATES["verification_wrong_prefix"]
       else:
           # Device never appeared (timeout)
           template = ERROR_TEMPLATES["verification_timeout"]
       out.error_with_recovery(
           template["error_type"],
           template["message_template"],
           context={"device": device_key, "pattern": entry.serial_pattern},
           recovery=template["recovery_template"],
       )
       return 1

   else:
       # flash_result.success was False
       out.error(f"Flash failed: {flash_result.error_message}")
       return 1
   ```

4. **Per VERIFY-06:** "Klipper still restarted even if verification fails" - this is guaranteed by the context manager. The `with klipper_service_stopped():` block ensures service restart on ANY exit path (success, failure, exception).

5. **Per VERIFY-04:** "Success message shows device path" - included in the verified=True branch.
  </action>
  <verify>
Syntax check: `python -m py_compile kalico-flash/flash.py`
Manual test on Pi: Flash device, observe "Verifying...." with dots, see success message with path
  </verify>
  <done>cmd_flash() calls wait_for_device() inside context manager after flash, shows device path on success, recovery steps on failure, Klipper always restarts</done>
</task>

</tasks>

<verification>
1. `python -m py_compile kalico-flash/tui.py` - no syntax errors
2. `python -m py_compile kalico-flash/errors.py` - no syntax errors
3. `python -m py_compile kalico-flash/flash.py` - no syntax errors
4. Flash a device -> see "Verifying...." with dots appearing every 2 seconds
5. Successful flash -> see "Device confirmed at: /dev/serial/by-id/..." message
6. Klipper restarts regardless of verification outcome
7. If verification fails (simulated), see recovery steps with diagnostic commands
</verification>

<success_criteria>
- wait_for_device() polls for 30 seconds with progress dots
- Successful verification shows device path
- Timeout shows recovery steps with physical checks first
- Wrong prefix (katapult_) treated as failure with specific guidance
- Klipper service restarts even when verification fails
- Requirements addressed: VERIFY-01, VERIFY-02 (30s per CONTEXT.md), VERIFY-03, VERIFY-04, VERIFY-05, VERIFY-06
</success_criteria>

<output>
After completion, create `.planning/phases/06-user-experience/06-03-SUMMARY.md`
</output>
