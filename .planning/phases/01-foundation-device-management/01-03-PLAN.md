---
phase: 01-foundation-device-management
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - klipper-flash/flash.py
autonomous: true

must_haves:
  truths:
    - "python3 flash.py --list-devices shows registered devices with [OK] or [--] connection status"
    - "Connected devices show their actual /dev/serial/by-id/ path"
    - "Disconnected devices show [--] (disconnected) marker"
    - "Unregistered USB devices appear as [??] Unknown with their serial filename"
    - "Empty registry with USB devices present offers to register"
  artifacts:
    - path: "klipper-flash/flash.py"
      provides: "Complete list-devices command with discovery integration"
      contains: "cmd_list_devices"
  key_links:
    - from: "klipper-flash/flash.py cmd_list_devices"
      to: "klipper-flash/discovery.py"
      via: "scan_serial_devices + find_registered_devices for cross-referencing"
      pattern: "find_registered_devices"
    - from: "klipper-flash/flash.py cmd_list_devices"
      to: "klipper-flash/registry.py"
      via: "Registry.load() for device list and global config"
      pattern: "registry\\.load"
---

<objective>
Implement the --list-devices command with full USB discovery integration: cross-reference registered devices against live USB scan, show connection status, flag unknown devices, and handle the first-run empty-registry experience.

Purpose: Complete the device management feature set for Phase 1. This is the primary status-checking command users will run -- it must clearly show which boards are connected, which are registered but disconnected, and which are unknown USB devices that could be registered.

Output: Fully functional --list-devices command in flash.py that satisfies RGST-04, DISC-01, DISC-02, DISC-03, and DISC-04.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-device-management/01-CONTEXT.md
@.planning/phases/01-foundation-device-management/01-RESEARCH.md
@.planning/phases/01-foundation-device-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-device-management/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: List-devices with discovery integration and connection status</name>
  <files>klipper-flash/flash.py</files>
  <action>
Replace the --list-devices stub in flash.py with a full implementation of `cmd_list_devices(registry, out) -> int`.

**Step 1 -- Load registry and scan USB:**
- Load registry data: `data = registry.load()`
- Import and call `discovery.scan_serial_devices()` to get live USB devices
- Import `discovery.find_registered_devices` to cross-reference

**Step 2 -- Cross-reference:**
- Call `find_registered_devices(usb_devices, data.devices)` to get `(matched, unmatched)` lists
- Build a set of matched device keys for quick lookup

**Step 3 -- Display registered devices:**
- out.info("Devices", f"{len(data.devices)} registered, {len(usb_devices)} USB devices found")
- If no registered devices AND no USB devices: out.info("Devices", "No registered devices and no USB devices found."), return 0

**Empty registry + USB devices present (first-run UX per CONTEXT.md):**
- If no registered devices BUT USB devices exist:
  - out.info("Devices", f"No registered devices. Found {len(usb_devices)} USB devices.")
  - For each USB device: out.device_line("??", "Unknown device", f"[{device.filename}]")
  - out.info("Devices", "Run --add-device to register a board.")
  - return 0

**Normal display (has registered devices):**
- For each registered device in data.devices (sorted by key):
  - Check if it's in the matched set
  - If connected (matched): `out.device_line("OK", f"{entry.name} ({entry.mcu})", device.path)`
    - Format: `  [OK] Octopus Pro v1.1 (stm32h723)   /dev/serial/by-id/usb-Klipper_stm32h723xx_...`
  - If disconnected (not matched): `out.device_line("--", f"{entry.name} ({entry.mcu})", "(disconnected)")`
    - Format: `  [--] Octopus Pro v1.1 (stm32h723)   (disconnected)`
  - Prepend the device key to the name or show on same line: the compact format from CONTEXT.md is `"octopus-pro: Octopus Pro v1.1 (stm32h723) [OK] /dev/serial/by-id/..."`. Use this format:
    - Connected: `out.device_line("OK", f"{entry.key}: {entry.name} ({entry.mcu})", device.path)`
    - Disconnected: `out.device_line("--", f"{entry.key}: {entry.name} ({entry.mcu})", "(disconnected)")`

**Step 4 -- Display unmatched (unknown) devices:**
- If there are unmatched USB devices:
  - Blank line for separation
  - For each unmatched device:
    - `out.device_line("??", "Unknown device", f"[{device.filename}]")`
  - out.info("Devices", "Use --add-device to register unknown devices.")

- return 0

**Important details:**
- The matched list from find_registered_devices is a list of (DeviceEntry, DiscoveredDevice) tuples. Build a dict keyed by device entry key for fast lookup.
- All output goes through `out` methods -- no bare print().
- Discovery scan may return empty list (no USB devices connected, or /dev/serial/by-id/ doesn't exist). Handle gracefully.
- This function does NOT modify the registry -- read-only operation.
  </action>
  <verify>
Since USB device scanning depends on Linux /dev/serial/by-id/ (not available on Windows dev machine), verify structural correctness:

Run: `cd klipper-flash && python3 -c "from flash import cmd_list_devices; print('cmd_list_devices importable')"` -- must succeed.

Create a test registry and run list-devices against it (no USB devices on dev machine = all show disconnected):
Run: `cd klipper-flash && python3 -c "
import json, os
# Create a test registry file
test_data = {
    'global': {'klipper_dir': '~/klipper', 'katapult_dir': '~/katapult', 'default_flash_method': 'katapult'},
    'devices': {
        'test-board': {'name': 'Test Board', 'mcu': 'stm32h723', 'serial_pattern': 'usb-test*', 'flash_method': None}
    }
}
with open('test_list.json', 'w') as f:
    json.dump(test_data, f)

from registry import Registry
from output import CliOutput
from flash import cmd_list_devices
r = Registry('test_list.json')
out = CliOutput()
result = cmd_list_devices(r, out)
assert result == 0, f'Expected exit 0, got {result}'
os.unlink('test_list.json')
print('list-devices OK')
"` -- must show the test board as disconnected and print "list-devices OK".

Run: `cd klipper-flash && python3 flash.py --list-devices` -- must not crash (may show "No registered devices" or empty list depending on whether devices.json exists).
  </verify>
  <done>
cmd_list_devices shows registered devices with connection status ([OK] with path or [--] disconnected), flags unknown USB devices as [??], handles empty registry with first-run messaging, and handles no-USB-devices gracefully. All output through Output Protocol.
  </done>
</task>

<task type="auto">
  <name>Task 2: Edge cases, --device flag validation, and final integration check</name>
  <files>klipper-flash/flash.py</files>
  <action>
Polish the CLI for edge cases and ensure all Phase 1 requirements are met.

**--device flag validation (RGST-05):**
- In the main() dispatch, when `args.device` is provided (without a management command), validate the device exists in registry:
  - `entry = registry.get(args.device)`
  - If not found: out.error(f"Device '{args.device}' not found. Run --list-devices to see registered devices."), return 1
  - If found: out.info("Device", f"Selected: {entry.name} ({entry.mcu})"), then fall through to the "flash not yet implemented" message with return 1

**Remove-device with optional config cleanup (RGST-03 enhancement):**
- After removing the device from registry, check if a configs/ directory exists with a cached config for this device (path: `configs/{key}.config`).
- If config file exists: out.confirm(f"Also remove cached config for '{key}'?", default=False)
  - If yes: delete the config file (and .sha256 sidecar if exists), out.success("Cached config removed")
  - If no: out.info("Registry", "Cached config kept")
- Note: configs/ directory may not exist yet in Phase 1 (created in Phase 2). Handle FileNotFoundError gracefully.

**Help text polish:**
- Ensure argparse epilog or description mentions: "Device management: --add-device, --list-devices, --remove-device. Flash workflow coming in future update."
- Add `--version` flag that prints "klipper-flash v0.1.0" (hardcoded for now)

**File header:**
- Add a module docstring to flash.py: brief description, usage example, and note that this is the CLI entry point (ARCH-02)
- Add `#!/usr/bin/env python3` shebang line as the very first line (before __future__ import)

**Final integration smoke test:**
- Verify all cmd_* functions are defined and callable
- Verify all imports resolve without circular dependency issues
- Verify error handling catches all KlipperFlashError subclasses
  </action>
  <verify>
Run: `cd klipper-flash && python3 flash.py --version` -- must print version string.
Run: `cd klipper-flash && python3 flash.py --device nonexistent` -- must show "not found" error with suggestion to run --list-devices.
Run: `cd klipper-flash && python3 flash.py --help` -- must show all options with clear help text.
Run: `cd klipper-flash && python3 -c "
# Full import chain test -- no circular imports
import errors
import models
import output
import registry
import discovery
import flash
print('All modules import cleanly')

# Verify architecture: no sys.exit in library modules
import inspect, sys
for mod in [errors, models, output, registry, discovery]:
    source = inspect.getsource(mod)
    assert 'sys.exit' not in source, f'{mod.__name__} contains sys.exit!'
    # Allow print only in output.py's CliOutput
    if mod is not output:
        # Simple check -- not in function bodies
        lines = [l.strip() for l in source.split(chr(10)) if l.strip().startswith('print(')]
        assert len(lines) == 0, f'{mod.__name__} contains bare print()!'
print('Architecture constraints verified')
"` -- must print both success messages.
  </verify>
  <done>
flash.py is complete with all Phase 1 CLI features: --add-device wizard, --remove-device with config cleanup, --list-devices with discovery integration, --device validation, --version flag, proper help text, shebang line. All architecture constraints verified. Requirements fully addressed: RGST-01 through RGST-05, DISC-01 through DISC-04, ARCH-01 through ARCH-06.
  </done>
</task>

</tasks>

<verification>
**Full Phase 1 verification checklist:**

1. **ARCH-01**: No sys.exit() in errors.py, models.py, output.py, registry.py, discovery.py -- only in flash.py
2. **ARCH-02**: flash.py is thin wrapper -- all logic in library modules, flash.py only does argparse + dispatch + error handling
3. **ARCH-03**: No print() in library modules except output.py's CliOutput class. All output via Output Protocol.
4. **ARCH-04**: Hub-and-spoke: registry.py and discovery.py do not import each other. flash.py coordinates.
5. **ARCH-05**: All cross-module data uses dataclasses (DeviceEntry, DiscoveredDevice, RegistryData, GlobalConfig)
6. **ARCH-06**: No external dependencies -- `pip list` not needed, only stdlib imports
7. **RGST-01**: devices.json has global + devices schema, persisted with atomic writes
8. **RGST-02**: --add-device wizard: scan, select, name, MCU auto-detect, serial pattern, flash method, persist
9. **RGST-03**: --remove-device with confirmation and optional config cleanup
10. **RGST-04**: --list-devices shows all registered devices with connection status
11. **RGST-05**: --device NAME validates device exists in registry
12. **DISC-01**: scan_serial_devices scans /dev/serial/by-id/ and match_device uses fnmatch
13. **DISC-02**: Connected devices show friendly name, unregistered show "Unknown"
14. **DISC-03**: Unknown devices flagged with [??] marker and registration suggestion
15. **DISC-04**: Connection status shown: [OK] connected with path, [--] disconnected

Run: `python3 flash.py --help && python3 flash.py --version && python3 flash.py --list-devices`
All must complete without errors.
</verification>

<success_criteria>
- All 14 Phase 1 requirements (ARCH-01 through ARCH-06, RGST-01 through RGST-05, DISC-01 through DISC-04) are implemented and verifiable
- Six Python files exist in klipper-flash/: flash.py, errors.py, models.py, output.py, registry.py, discovery.py
- flash.py is executable with shebang line
- All management commands work: --add-device, --remove-device, --list-devices
- Discovery integration shows live connection status
- Architecture constraints enforced throughout
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-management/01-03-SUMMARY.md`
</output>
