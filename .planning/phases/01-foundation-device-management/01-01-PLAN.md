---
phase: 01-foundation-device-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - klipper-flash/errors.py
  - klipper-flash/models.py
  - klipper-flash/output.py
  - klipper-flash/registry.py
  - klipper-flash/discovery.py
autonomous: true

must_haves:
  truths:
    - "All five library modules (errors, models, output, registry, discovery) are importable without errors on Python 3.9+"
    - "Registry can load, save, add, remove, list, and get devices with atomic JSON writes"
    - "Discovery can scan a directory and match devices against glob patterns"
    - "Output Protocol defines pluggable interface -- no print() or sys.exit() in any library module"
    - "Dataclasses define cross-module contracts -- no raw dicts passed between modules"
  artifacts:
    - path: "klipper-flash/errors.py"
      provides: "Exception hierarchy (KlipperFlashError, RegistryError, DeviceNotFoundError, DiscoveryError)"
      contains: "class KlipperFlashError"
    - path: "klipper-flash/models.py"
      provides: "Dataclass contracts (GlobalConfig, DeviceEntry, DiscoveredDevice, RegistryData)"
      contains: "class DeviceEntry"
    - path: "klipper-flash/output.py"
      provides: "Output Protocol + CliOutput + NullOutput implementations"
      contains: "class Output"
    - path: "klipper-flash/registry.py"
      provides: "Registry class with JSON CRUD and atomic writes"
      contains: "class Registry"
    - path: "klipper-flash/discovery.py"
      provides: "USB serial scanning, pattern matching, MCU extraction, serial pattern generation"
      contains: "def scan_serial_devices"
  key_links:
    - from: "klipper-flash/registry.py"
      to: "klipper-flash/models.py"
      via: "imports DeviceEntry, GlobalConfig, RegistryData"
      pattern: "from models import"
    - from: "klipper-flash/registry.py"
      to: "klipper-flash/errors.py"
      via: "raises RegistryError"
      pattern: "from errors import"
    - from: "klipper-flash/discovery.py"
      to: "klipper-flash/models.py"
      via: "imports DiscoveredDevice"
      pattern: "from models import"
---

<objective>
Create the klipper-flash project skeleton and all five foundational Python library modules: error hierarchy, dataclass contracts, pluggable output interface, device registry with atomic JSON persistence, and USB discovery with pattern matching.

Purpose: Establish the complete importable library layer that Plans 02 and 03 will wire into the CLI. Every cross-module contract, persistence pattern, and output abstraction must be in place before any CLI code is written.

Output: Five production-ready Python modules in klipper-flash/ directory, each independently importable with no sys.exit() or print() calls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-device-management/01-CONTEXT.md
@.planning/phases/01-foundation-device-management/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project skeleton, errors, models, and output modules</name>
  <files>
    klipper-flash/errors.py
    klipper-flash/models.py
    klipper-flash/output.py
  </files>
  <action>
Create the `klipper-flash/` directory at the repository root.

**errors.py** -- Centralized exception hierarchy:
- `from __future__ import annotations` at top (Python 3.9 compat -- do this in EVERY module)
- `KlipperFlashError(Exception)` -- base for all project errors
- `RegistryError(KlipperFlashError)` -- corrupt JSON, duplicate keys, missing fields
- `DeviceNotFoundError(KlipperFlashError)` -- device not in registry or not connected. Constructor takes `identifier: str`, stores as attribute, passes to super with message "Device not found: {identifier}"
- `DiscoveryError(KlipperFlashError)` -- USB discovery failures
- Comment placeholder for Phase 2/3 additions (BuildError, FlashError, ServiceError)
- NO sys.exit(), NO print(), NO imports from other project modules

**models.py** -- Dataclass contracts (NOT types.py -- shadows stdlib):
- `from __future__ import annotations` at top
- `GlobalConfig` dataclass: `klipper_dir: str = "~/klipper"`, `katapult_dir: str = "~/katapult"`, `default_flash_method: str = "katapult"`
- `DeviceEntry` dataclass: `key: str`, `name: str`, `mcu: str`, `serial_pattern: str`, `flash_method: Optional[str] = None` (None means inherit global default)
- `DiscoveredDevice` dataclass: `path: str` (full /dev/serial/by-id/... path), `filename: str` (just the symlink name)
- `RegistryData` dataclass: `global_config: GlobalConfig = field(default_factory=GlobalConfig)`, `devices: dict = field(default_factory=dict)` (key -> DeviceEntry)
- All paths stored as `str` not `Path` (JSON serialization pitfall from research)
- Use `typing.Optional` not `X | None` for field defaults (runtime compat)

**output.py** -- Pluggable output interface via Protocol:
- `from __future__ import annotations` at top
- `Output(Protocol)` with methods: `info(section: str, message: str)`, `success(message: str)`, `warn(message: str)`, `error(message: str)`, `device_line(marker: str, name: str, detail: str)`, `prompt(message: str, default: str = "") -> str`, `confirm(message: str, default: bool = False) -> bool`
- `CliOutput` class implementing Output -- plain text, no ANSI color:
  - info: `[{section}] {message}`
  - success: `[OK] {message}`
  - warn: `[!!] {message}`
  - error: `[FAIL] {message}` to stderr
  - device_line: `  [{marker}] {name:<24s} {detail}` (left-aligned, 24-char name field)
  - prompt: `{message} [{default}]: ` using input(), returns response or default
  - confirm: `{message} [Y/n]: ` or `[y/N]:` based on default, returns bool
- `NullOutput` class -- all methods are no-ops, prompt returns default, confirm returns default
- NO sys.exit(), NO imports from other project modules

Follow the exact code patterns from 01-RESEARCH.md. The research has verified examples for all three modules.
  </action>
  <verify>
Run: `cd klipper-flash && python3 -c "from errors import KlipperFlashError, RegistryError, DeviceNotFoundError, DiscoveryError; print('errors OK')"` -- must print "errors OK".
Run: `cd klipper-flash && python3 -c "from models import GlobalConfig, DeviceEntry, DiscoveredDevice, RegistryData; print('models OK')"` -- must print "models OK".
Run: `cd klipper-flash && python3 -c "from output import Output, CliOutput, NullOutput; n = NullOutput(); n.info('test', 'msg'); print('output OK')"` -- must print "output OK".
Grep all three files for `sys.exit` and `print(` (outside of output.py's CliOutput class) -- must find none.
  </verify>
  <done>
Three modules exist and are importable. errors.py exports 4 exception classes. models.py exports 4 dataclasses. output.py exports Output Protocol + CliOutput + NullOutput. No sys.exit() or bare print() in any library module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Registry and discovery modules</name>
  <files>
    klipper-flash/registry.py
    klipper-flash/discovery.py
  </files>
  <action>
**registry.py** -- Device registry backed by devices.json:
- `from __future__ import annotations` at top
- Imports from `models` (DeviceEntry, GlobalConfig, RegistryData) and `errors` (RegistryError)
- `Registry` class with constructor taking `registry_path: str`
- Methods:
  - `load() -> RegistryData`: Read devices.json, return RegistryData. If file missing, return default empty RegistryData(). If JSON corrupt, raise RegistryError with clear message. Parse "global" key into GlobalConfig, parse "devices" key into dict of DeviceEntry objects.
  - `save(registry: RegistryData) -> None`: Serialize RegistryData to JSON dict with "global" and "devices" top-level keys. Write using atomic pattern (tempfile + fsync + os.replace). Sort keys for deterministic output. Trailing newline.
  - `add(entry: DeviceEntry) -> None`: Load, check for duplicate key (raise RegistryError if exists), add to devices dict, save.
  - `remove(key: str) -> bool`: Load, remove key if exists (return True), save. Return False if key not found.
  - `get(key: str) -> Optional[DeviceEntry]`: Load, return device or None.
  - `list_all() -> list[DeviceEntry]`: Load, return list of all DeviceEntry values.
  - `load_global() -> GlobalConfig`: Load, return global_config.
  - `save_global(config: GlobalConfig) -> None`: Load, update global_config, save.
- Private function `_atomic_write_json(path: str, data: dict) -> None`:
  - Create temp file in same directory with NamedTemporaryFile(mode="w", dir=same_dir, delete=False, suffix=".tmp", encoding="utf-8")
  - json.dump with indent=2, sort_keys=True
  - Write trailing newline
  - flush() + os.fsync()
  - On any exception: os.unlink(tmp_path), re-raise
  - os.replace(tmp_path, path)
  - os.makedirs(dir, exist_ok=True) before creating temp file
- Per-device flash_method serialized as `null` in JSON when None (json.dump handles this automatically)
- NO sys.exit(), NO print(), NO imports from discovery or output

**discovery.py** -- USB serial scanning + pattern matching:
- `from __future__ import annotations` at top
- Imports from `models` (DiscoveredDevice) only. Does NOT import registry or output.
- Module constant: `SERIAL_BY_ID = "/dev/serial/by-id"`
- Functions:
  - `scan_serial_devices() -> list[DiscoveredDevice]`: Check if SERIAL_BY_ID directory exists (Path.is_dir()). If not, return empty list. Otherwise iterate sorted entries, create DiscoveredDevice for each with path=str(entry) and filename=entry.name.
  - `match_device(pattern: str, devices: list[DiscoveredDevice]) -> Optional[DiscoveredDevice]`: Use fnmatch.fnmatch to find first match. Return None if no match.
  - `find_registered_devices(devices: list[DiscoveredDevice], registry_devices: dict[str, DeviceEntry]) -> tuple[list[tuple[DeviceEntry, DiscoveredDevice]], list[DiscoveredDevice]]`: Cross-reference discovered vs registered. Return (matched_pairs, unmatched_devices).
  - `extract_mcu_from_serial(filename: str) -> Optional[str]`: Regex `r"usb-(?:Klipper|katapult)_([a-z0-9]+?)(?:x[a-z0-9]*)?_"` with re.IGNORECASE. Return lowercase MCU or None.
  - `generate_serial_pattern(filename: str) -> str`: Strip `-ifNN` suffix with regex `r"-if\d+$"`, append `*` wildcard.
- NO sys.exit(), NO print(), NO imports from registry or output

Follow the exact code patterns from 01-RESEARCH.md. The research provides verified implementations for both modules.
  </action>
  <verify>
Run: `cd klipper-flash && python3 -c "from registry import Registry; r = Registry('test_devices.json'); data = r.load(); print(f'devices: {len(data.devices)}'); print('registry OK')"` -- must print "devices: 0" and "registry OK".
Run: `cd klipper-flash && python3 -c "from discovery import scan_serial_devices, extract_mcu_from_serial, generate_serial_pattern; print(extract_mcu_from_serial('usb-Klipper_stm32h723xx_29001A-if00')); print(generate_serial_pattern('usb-Klipper_stm32h723xx_29001A-if00'))"` -- must print "stm32h723" and "usb-Klipper_stm32h723xx_29001A*".
Run a round-trip test: `cd klipper-flash && python3 -c "
from registry import Registry
from models import DeviceEntry
r = Registry('test_rt.json')
r.add(DeviceEntry(key='test', name='Test Board', mcu='stm32h723', serial_pattern='usb-test*'))
entry = r.get('test')
assert entry is not None and entry.name == 'Test Board'
assert r.remove('test') == True
assert r.get('test') is None
import os; os.unlink('test_rt.json')
print('round-trip OK')
"` -- must print "round-trip OK".
Clean up: remove test_devices.json if created.
Grep registry.py and discovery.py for `sys.exit` and `print(` -- must find none.
  </verify>
  <done>
registry.py provides Registry class with load/save/add/remove/get/list_all/load_global/save_global methods, using atomic JSON writes. discovery.py provides scan_serial_devices, match_device, find_registered_devices, extract_mcu_from_serial, and generate_serial_pattern functions. Both are importable, use dataclass contracts from models.py, raise errors from errors.py, and contain no sys.exit() or print() calls. Hub-and-spoke enforced: neither module imports the other.
  </done>
</task>

</tasks>

<verification>
1. All five modules import without errors: `python3 -c "import errors, models, output, registry, discovery"`
2. No module contains `sys.exit()` (ARCH-01) -- grep confirms
3. No library module contains bare `print()` outside CliOutput (ARCH-03) -- grep confirms
4. registry.py and discovery.py do not import each other (ARCH-04) -- grep confirms
5. All cross-module data uses dataclasses, not raw dicts (ARCH-05) -- code inspection
6. No external dependencies -- only stdlib imports (ARCH-06) -- grep confirms
7. Registry round-trip works: add device, get it back, remove it, verify gone
8. MCU extraction returns correct results for known serial paths
</verification>

<success_criteria>
- Five Python modules exist in klipper-flash/ directory
- All modules importable on Python 3.9+ (from __future__ import annotations in each)
- Registry CRUD works end-to-end with atomic JSON persistence
- Discovery functions work for scanning, matching, MCU extraction, pattern generation
- Architecture constraints enforced: no sys.exit, no print in library, no cross-module sibling imports, dataclass contracts, stdlib only
- Requirements addressed: ARCH-01, ARCH-03, ARCH-04, ARCH-05, ARCH-06, RGST-01 (schema)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-management/01-01-SUMMARY.md`
</output>
