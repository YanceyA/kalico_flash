---
phase: 01-foundation-device-management
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - klipper-flash/flash.py
autonomous: true

must_haves:
  truths:
    - "python3 flash.py --add-device walks through interactive wizard and persists a new device to devices.json"
    - "python3 flash.py --remove-device NAME removes a device and reports success or not-found"
    - "flash.py is a thin CLI wrapper -- all logic delegates to library modules"
    - "Global config (klipper_dir, katapult_dir) is prompted and saved during first add-device"
  artifacts:
    - path: "klipper-flash/flash.py"
      provides: "CLI entry point with argparse, dispatch, add-device wizard, remove-device command"
      contains: "def main"
      exports: ["main", "build_parser"]
  key_links:
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/registry.py"
      via: "Registry class for add/remove operations"
      pattern: "from registry import"
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/discovery.py"
      via: "scan_serial_devices, extract_mcu_from_serial, generate_serial_pattern for wizard"
      pattern: "from discovery import"
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/output.py"
      via: "CliOutput for all user-facing output"
      pattern: "from output import"
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/errors.py"
      via: "KlipperFlashError catch at top level"
      pattern: "from errors import"
---

<objective>
Create the CLI entry point (flash.py) with argparse dispatch, the interactive add-device wizard, and the remove-device command. This wires the library modules from Plan 01 into user-facing CLI commands.

Purpose: Deliver the first two user-facing device management operations: registering a new board via interactive wizard and removing a registered board. The add-device wizard is the most complex interactive flow in Phase 1 -- it scans USB devices, auto-extracts MCU, generates serial patterns, prompts for global config on first run, and persists to devices.json.

Output: flash.py with working --add-device and --remove-device commands, plus a stub for --list-devices (implemented in Plan 03).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-device-management/01-CONTEXT.md
@.planning/phases/01-foundation-device-management/01-RESEARCH.md
@.planning/phases/01-foundation-device-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CLI scaffold with argparse and dispatch</name>
  <files>klipper-flash/flash.py</files>
  <action>
Create `klipper-flash/flash.py` -- the thin CLI wrapper (ARCH-02).

- `from __future__ import annotations` at top
- Python version guard: check `sys.version_info < (3, 9)`, sys.exit with clear message if too old
- `build_parser() -> argparse.ArgumentParser`:
  - prog="flash.py"
  - description: "Build and flash Klipper firmware for USB-connected MCU boards."
  - `--device NAME` argument (metavar="NAME", help text)
  - Mutually exclusive group for management commands:
    - `--add-device` (action="store_true")
    - `--list-devices` (action="store_true")
    - `--remove-device NAME` (metavar="NAME")
  - Future flags (Phase 2/3) as comments only, not implemented

- `main() -> int`:
  - Parse args
  - Late imports (keep startup fast): CliOutput, Registry, KlipperFlashError
  - Create `out = CliOutput()`
  - Determine registry path: `Path(__file__).parent / "devices.json"` (next to flash.py)
  - Create `registry = Registry(str(registry_path))`
  - Try/except dispatch:
    - `args.add_device` -> `cmd_add_device(registry, out)`
    - `args.list_devices` -> `cmd_list_devices(registry, out)` (stub returning 0 with out.info message "List devices not yet implemented")
    - `args.remove_device` -> `cmd_remove_device(registry, args.remove_device, out)`
    - else -> out.error("Flash workflow not yet implemented. Use --add-device, --list-devices, or --remove-device."), return 1
  - Exception handling:
    - KeyboardInterrupt -> print("\nAborted."), return 130
    - KlipperFlashError -> out.error(str(e)), return 1
    - Exception -> out.error(f"Unexpected error: {e}"), return 3

- `if __name__ == "__main__": sys.exit(main())`

- `cmd_remove_device(registry, device_key, out) -> int`:
  - Check if device exists first (registry.get)
  - If not found: out.error(f"Device '{device_key}' not found in registry"), return 1
  - Confirm removal via out.confirm(f"Remove '{device_key}' ({entry.name})?")
  - If confirmed: registry.remove(device_key), out.success(f"Removed '{device_key}'"), return 0
  - If declined: out.info("Registry", "Removal cancelled"), return 0

This task creates the scaffold. The add-device wizard implementation is Task 2.
  </action>
  <verify>
Run: `cd klipper-flash && python3 flash.py --help` -- must show help text with --add-device, --list-devices, --remove-device, --device options.
Run: `cd klipper-flash && python3 flash.py --list-devices` -- must show "not yet implemented" message (stub), exit 0.
Run: `cd klipper-flash && python3 flash.py` -- must show error about flash not implemented, exit 1.
Run: `cd klipper-flash && python3 flash.py --remove-device nonexistent` -- must show "not found" error, exit 1.
  </verify>
  <done>
flash.py exists with argparse, dispatch to management commands, remove-device working, list-devices stubbed, proper error handling and exit codes. CLI is thin wrapper over library modules (ARCH-02).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add-device wizard with interactive flow</name>
  <files>klipper-flash/flash.py</files>
  <action>
Implement `cmd_add_device(registry, out) -> int` in flash.py. This is the interactive wizard per CONTEXT.md decisions.

**TTY check (Pitfall 7 from research):**
- Before starting wizard, check `sys.stdin.isatty()`. If not interactive, out.error("Interactive terminal required for --add-device. Run from SSH terminal."), return 1.

**Step 1 -- Scan USB devices:**
- Import and call `discovery.scan_serial_devices()`
- If empty list: out.error("No USB devices found. Plug in a board and try again."), return 1
- Display found devices with numbered list via out.info("Discovery", f"Found {len} USB serial devices:")
- For each device, print numbered line: `out.device_line(str(i+1), device.filename, device.path)`

**Step 2 -- Select device:**
- out.prompt("Select device number", default="1")
- Validate: must be integer in range. On invalid input, re-prompt (loop with max 3 attempts).
- Store selected DiscoveredDevice.

**Step 3 -- Global config (first run only):**
- Load registry. If registry has no devices yet (first time), prompt for global paths:
  - klipper_dir: out.prompt("Klipper source directory", default="~/klipper")
  - katapult_dir: out.prompt("Katapult source directory", default="~/katapult")
  - Save global config via registry.save_global(GlobalConfig(...))
- If registry already has devices, skip this step (global config already set).

**Step 4 -- Device key:**
- out.prompt("Device key (used with --device flag, e.g., 'octopus-pro')")
- Validate: non-empty, no spaces. Check for duplicate key in registry (Pitfall 5). If duplicate, show error and re-prompt.

**Step 5 -- Display name:**
- out.prompt("Display name (e.g., 'Octopus Pro v1.1')")

**Step 6 -- MCU auto-detection:**
- Call `discovery.extract_mcu_from_serial(selected_device.filename)`
- If detected: out.confirm(f"Detected MCU: {mcu}. Correct?", default=True)
  - If confirmed, use detected MCU
  - If declined, out.prompt("Enter MCU type")
- If not detected (non-Klipper device): out.prompt("MCU type (e.g., stm32h723, rp2040)")

**Step 7 -- Serial pattern:**
- Auto-generate via `discovery.generate_serial_pattern(selected_device.filename)`
- Show to user: out.info("Registry", f"Serial pattern: {pattern}")
- Check for overlap against existing registered devices (Pitfall 6): for each existing entry, check if the new pattern matches any device that the existing pattern also matches, or vice versa. If overlap detected, out.warn with message but allow proceeding.

**Step 8 -- Flash method:**
- out.prompt("Flash method", default="katapult") -- accepted values: "katapult", "make_flash"
- Validate input. If not recognized, re-prompt.
- If "katapult" (same as global default), store as None (inherits global). Otherwise store the chosen value.

**Step 9 -- Create and save:**
- Create DeviceEntry with collected values
- registry.add(entry)
- out.success(f"Registered '{key}' ({name})")
- return 0

**Important implementation notes:**
- All user interaction goes through `out.prompt()` and `out.confirm()` -- never bare `input()` (ARCH-03)
- All data persistence goes through `registry` -- never direct file writes (ARCH-04)
- On any validation failure, provide clear message and re-prompt (focused utility feel per CONTEXT.md)
- The wizard should feel simple and linear -- no menus within menus
  </action>
  <verify>
Since this is an interactive wizard, full verification requires a TTY. Verify non-interactive behavior:
Run: `cd klipper-flash && echo "" | python3 flash.py --add-device 2>&1` -- should show "Interactive terminal required" error (stdin is pipe, not TTY) OR show the wizard prompts (depending on isatty behavior with pipe). Either way, must not crash with unhandled exception.

Verify the wizard functions exist and are callable:
Run: `cd klipper-flash && python3 -c "from flash import cmd_add_device, cmd_remove_device, build_parser; print('commands OK')"` -- must print "commands OK".

Verify no import errors in the full module:
Run: `cd klipper-flash && python3 -c "import flash; print('flash module OK')"` -- must print "flash module OK".

Verify argparse still works:
Run: `cd klipper-flash && python3 flash.py --help` -- must show all options including --add-device.
  </verify>
  <done>
The add-device wizard is fully implemented in flash.py: scans USB devices, selects device, prompts for global config on first run, collects device key/name/MCU/flash method, auto-generates serial pattern, validates for duplicates and overlaps, persists to devices.json via Registry. All I/O through Output Protocol. Requirements addressed: RGST-02 (wizard flow), RGST-05 (--device flag defined in argparse), ARCH-02 (thin CLI wrapper).
  </done>
</task>

</tasks>

<verification>
1. `python3 flash.py --help` shows all management options
2. `python3 flash.py --remove-device nonexistent` returns exit code 1 with clear error
3. flash.py imports all library modules (registry, discovery, output, errors, models) without circular imports
4. cmd_add_device function exists and handles non-TTY gracefully
5. Only flash.py contains sys.exit() -- library modules do not (ARCH-01)
6. All user interaction goes through Output Protocol methods (ARCH-03)
</verification>

<success_criteria>
- flash.py is the CLI entry point with argparse and dispatch
- --add-device wizard implements full interactive flow per CONTEXT.md decisions
- --remove-device works with confirmation prompt
- --list-devices is stubbed (Plan 03 implements it)
- Global config prompted on first add-device run
- All architecture constraints maintained (ARCH-01 through ARCH-04)
- Requirements addressed: RGST-02, RGST-03, RGST-05, ARCH-01, ARCH-02
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-device-management/01-02-SUMMARY.md`
</output>
