---
phase: 02-build-config-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - klipper-flash/errors.py
  - klipper-flash/config.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Per-device .config cached in XDG config directory"
    - "Cached config restored to klipper dir before menuconfig"
    - "Config saved back to cache after menuconfig completes"
    - "MCU type extracted from .config file"
    - "MCU mismatch between config and registry blocks operation with clear error"
  artifacts:
    - path: "klipper-flash/errors.py"
      provides: "ConfigError exception class"
      contains: "class ConfigError"
    - path: "klipper-flash/config.py"
      provides: "Config caching, MCU parsing, atomic writes"
      exports: ["ConfigManager", "get_config_dir", "parse_mcu_from_config"]
      min_lines: 80
  key_links:
    - from: "klipper-flash/config.py"
      to: "klipper-flash/errors.py"
      via: "import ConfigError"
      pattern: "from errors import.*ConfigError"
    - from: "klipper-flash/config.py"
      to: "atomic write pattern"
      via: "tempfile + os.replace"
      pattern: "os\\.replace"
---

<objective>
Create config.py module for per-device .config caching with XDG paths, atomic writes, MCU extraction, and registry validation

Purpose: Enable safe config caching so users don't lose menuconfig changes between builds, and prevent wrong-MCU firmware from being built
Output: ConfigManager class with load_cached_config, save_cached_config, validate_mcu methods
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-build-config-pipeline/02-RESEARCH.md
@.planning/phases/02-build-config-pipeline/02-CONTEXT.md

@klipper-flash/errors.py
@klipper-flash/models.py
@klipper-flash/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConfigError and create config.py with XDG paths and MCU parsing</name>
  <files>klipper-flash/errors.py, klipper-flash/config.py</files>
  <action>
Update errors.py to add ConfigError class following existing pattern:
```python
class ConfigError(KlipperFlashError):
    """Config file errors: missing, corrupt, MCU mismatch."""
    pass
```

Create klipper-flash/config.py with:

1. XDG config directory resolution:
   - Check XDG_CONFIG_HOME env var (if set and absolute)
   - Fallback to ~/.config
   - Return Path for klipper-flash/configs/{device-key}/

2. MCU parsing function:
   - parse_mcu_from_config(config_path: str) -> Optional[str]
   - Read .config file, regex match CONFIG_MCU="..."
   - Return MCU string (e.g., "stm32h723xx") or None if not found

3. ConfigManager class with __init__(device_key: str, klipper_dir: str):
   - Store device_key, klipper_dir
   - Resolve cache_path using XDG function
   - Resolve klipper_config_path (klipper_dir/.config)

Follow existing patterns:
- `from __future__ import annotations` at top
- Use typing.Optional for compatibility
- Import ConfigError from errors
- No sys.exit() or print() in library module
  </action>
  <verify>
python -c "from config import get_config_dir, parse_mcu_from_config, ConfigManager; print('Imports OK')"
python -c "from config import get_config_dir; print(get_config_dir('test-device'))"
  </verify>
  <done>
- ConfigError added to errors.py
- config.py created with get_config_dir(), parse_mcu_from_config(), ConfigManager class
- XDG_CONFIG_HOME respected when set
- MCU parsing extracts CONFIG_MCU value from .config content
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache operations and MCU validation to ConfigManager</name>
  <files>klipper-flash/config.py</files>
  <action>
Add methods to ConfigManager class:

1. load_cached_config() -> bool:
   - If cache_path exists, atomic_copy(cache_path, klipper_config_path)
   - Return True if copied, False if no cache exists
   - Create parent directories as needed

2. save_cached_config() -> None:
   - atomic_copy(klipper_config_path, cache_path)
   - Raises ConfigError if klipper .config doesn't exist

3. validate_mcu(expected_mcu: str) -> tuple[bool, Optional[str]]:
   - Parse MCU from klipper_config_path using parse_mcu_from_config
   - Compare using prefix matching (stm32h723 matches stm32h723xx)
   - Return (is_match, actual_mcu)
   - Raises ConfigError if .config doesn't exist or has no CONFIG_MCU

4. atomic_copy(src: str, dst: str) -> None:
   - Follow research pattern: tempfile + shutil.copyfileobj + fsync + os.replace
   - Create destination directory if needed
   - Clean up temp file on failure

5. get_mtime() -> Optional[float]:
   - Return mtime of klipper .config file, or None if doesn't exist
   - Used by build.py to detect if menuconfig saved changes

Handle edge cases:
- Cache directory doesn't exist (create it)
- Klipper .config doesn't exist (return False from load, raise from save)
- MCU line not found in .config (raise ConfigError with clear message)
  </action>
  <verify>
python -c "
from config import ConfigManager
import tempfile, os
# Create test klipper dir with .config
with tempfile.TemporaryDirectory() as kd:
    config_content = 'CONFIG_MCU=\"stm32h723xx\"\nCONFIG_SOMETHING_ELSE=y\n'
    with open(os.path.join(kd, '.config'), 'w') as f:
        f.write(config_content)

    cm = ConfigManager('test-device', kd)

    # Test MCU validation
    is_match, actual = cm.validate_mcu('stm32h723')
    assert is_match, f'MCU should match (prefix), got {actual}'
    assert actual == 'stm32h723xx', f'Actual should be stm32h723xx, got {actual}'

    # Test cache save
    cm.save_cached_config()
    assert cm.cache_path.exists(), 'Cache should exist after save'

    # Test mtime
    mtime = cm.get_mtime()
    assert mtime is not None, 'mtime should be returned'

    print('All config tests passed')
"
  </verify>
  <done>
- ConfigManager has load_cached_config, save_cached_config, validate_mcu, get_mtime methods
- atomic_copy uses tempfile + fsync + os.replace pattern
- MCU validation uses prefix matching
- ConfigError raised for missing .config or MCU line
- All edge cases handled (missing cache, missing klipper config)
  </done>
</task>

</tasks>

<verification>
All verification commands pass:
- python -c "from config import ConfigManager, get_config_dir, parse_mcu_from_config"
- python -c "from errors import ConfigError"
- Full integration test with temp directories and MCU validation
</verification>

<success_criteria>
1. config.py module exists with ConfigManager class
2. XDG config directory resolved correctly
3. MCU parsing extracts CONFIG_MCU from .config files
4. Atomic copy operations prevent file corruption
5. MCU validation uses prefix matching (stm32h723 matches stm32h723xx)
6. ConfigError raised on missing config or MCU mismatch
</success_criteria>

<output>
After completion, create `.planning/phases/02-build-config-pipeline/02-01-SUMMARY.md`
</output>
