---
phase: 02-build-config-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - klipper-flash/errors.py
  - klipper-flash/models.py
  - klipper-flash/build.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "make menuconfig runs with full ncurses TUI visible"
    - "User can interact with menuconfig normally (keyboard navigation, save, exit)"
    - "make clean followed by make -j runs with real-time output streaming"
    - "Build success reports klipper.bin file size and elapsed time"
    - "Build failure reports error and returns non-zero exit code"
  artifacts:
    - path: "klipper-flash/errors.py"
      provides: "BuildError exception class"
      contains: "class BuildError"
    - path: "klipper-flash/models.py"
      provides: "BuildResult dataclass"
      contains: "class BuildResult"
    - path: "klipper-flash/build.py"
      provides: "Menuconfig passthrough and make build"
      exports: ["run_menuconfig", "run_build", "Builder"]
      min_lines: 60
  key_links:
    - from: "klipper-flash/build.py"
      to: "subprocess.run with inherited stdio"
      via: "no PIPE redirection"
      pattern: "subprocess\\.run.*cwd="
    - from: "klipper-flash/build.py"
      to: "klipper-flash/config.py"
      via: "ConfigManager for cache operations"
      pattern: "from config import"
---

<objective>
Create build.py module for menuconfig TUI passthrough and firmware building with streaming output

Purpose: Enable interactive firmware configuration and compilation with familiar Klipper workflow (make menuconfig, make clean, make)
Output: Builder class with run_menuconfig (inherited stdio for ncurses) and run_build (streaming make output)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-build-config-pipeline/02-RESEARCH.md
@.planning/phases/02-build-config-pipeline/02-CONTEXT.md
@.planning/phases/02-build-config-pipeline/02-01-SUMMARY.md

@klipper-flash/errors.py
@klipper-flash/models.py
@klipper-flash/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BuildError, BuildResult dataclass, and create build.py with menuconfig passthrough</name>
  <files>klipper-flash/errors.py, klipper-flash/models.py, klipper-flash/build.py</files>
  <action>
Update errors.py to add BuildError class:
```python
class BuildError(KlipperFlashError):
    """Build failures: make menuconfig, make clean, make."""
    pass
```

Update models.py to add BuildResult dataclass:
```python
@dataclass
class BuildResult:
    """Result of a firmware build."""
    success: bool
    firmware_path: Optional[str] = None  # Path to klipper.bin if success
    firmware_size: int = 0               # Size in bytes if success
    elapsed_seconds: float = 0.0         # Build duration
    error_message: Optional[str] = None  # Error details if failed
```

Create klipper-flash/build.py with:

1. run_menuconfig(klipper_dir: str, config_path: str) -> tuple[int, bool]:
   - Set KCONFIG_CONFIG env var to ABSOLUTE path of config_path
   - Run subprocess.run(["make", "menuconfig"], cwd=klipper_dir, env=env)
   - NO stdin/stdout/stderr args (inherited stdio for ncurses TUI)
   - Check mtime before/after to detect if config was saved
   - Return (return_code, was_saved)

2. Use Path.expanduser() on klipper_dir to handle ~/klipper
3. Use Path.absolute() on config_path for KCONFIG_CONFIG

Follow existing patterns:
- `from __future__ import annotations` at top
- Import BuildError from errors
- No sys.exit() or print() in library module
  </action>
  <verify>
python -c "from build import run_menuconfig; print('Import OK')"
python -c "from errors import BuildError; print('BuildError OK')"
python -c "from models import BuildResult; print(BuildResult(success=True, firmware_size=1024))"
  </verify>
  <done>
- BuildError added to errors.py
- BuildResult dataclass added to models.py
- build.py created with run_menuconfig function
- KCONFIG_CONFIG uses absolute path
- Mtime comparison detects config save
- Inherited stdio allows ncurses TUI passthrough
  </done>
</task>

<task type="auto">
  <name>Task 2: Add run_build function with streaming output and firmware size reporting</name>
  <files>klipper-flash/build.py</files>
  <action>
Add to build.py:

1. run_build(klipper_dir: str) -> BuildResult:
   - Expand klipper_dir with Path.expanduser()
   - Get start time with time.monotonic()
   - Run subprocess.run(["make", "clean"], cwd=klipper_dir)
     - NO stdin/stdout/stderr args (inherited stdio for streaming)
     - If returncode != 0, return BuildResult with success=False
   - Get CPU count with multiprocessing.cpu_count()
   - Run subprocess.run(["make", f"-j{nproc}"], cwd=klipper_dir)
     - If returncode != 0, return BuildResult with success=False
   - Calculate elapsed time
   - Check firmware file: klipper_dir/out/klipper.bin
     - If exists, get size with Path.stat().st_size
     - If missing, return BuildResult with success=False, error about missing output
   - Return BuildResult with success=True, path, size, elapsed

2. Builder class (optional convenience wrapper):
   - __init__(klipper_dir: str)
   - menuconfig(config_path: str) -> tuple[int, bool]
   - build() -> BuildResult

Imports needed:
- subprocess
- time
- multiprocessing
- pathlib.Path
  </action>
  <verify>
python -c "
from build import run_build, Builder
from models import BuildResult
print('Imports OK')

# Verify BuildResult structure
result = BuildResult(
    success=True,
    firmware_path='/tmp/klipper/out/klipper.bin',
    firmware_size=24576,
    elapsed_seconds=45.2
)
print(f'BuildResult: success={result.success}, size={result.firmware_size}, time={result.elapsed_seconds}s')
"
  </verify>
  <done>
- run_build function executes make clean + make -j with streaming output
- No subprocess.PIPE used (inherited stdio for real-time output)
- BuildResult includes firmware_path, firmware_size, elapsed_seconds
- CPU count used for parallel make jobs
- Failure cases return BuildResult with success=False and error_message
- Firmware size verified after successful build
  </done>
</task>

</tasks>

<verification>
All verification commands pass:
- python -c "from build import run_menuconfig, run_build, Builder"
- python -c "from errors import BuildError"
- python -c "from models import BuildResult"
- BuildResult dataclass has all required fields
</verification>

<success_criteria>
1. build.py module exists with run_menuconfig and run_build functions
2. run_menuconfig uses inherited stdio (no PIPE) for ncurses TUI
3. KCONFIG_CONFIG env var set to absolute path
4. run_build executes make clean + make -j with streaming output
5. BuildResult includes success, firmware_path, firmware_size, elapsed_seconds
6. Firmware size verified from out/klipper.bin after build
7. Failure cases return proper BuildResult with error_message
</success_criteria>

<output>
After completion, create `.planning/phases/02-build-config-pipeline/02-02-SUMMARY.md`
</output>
