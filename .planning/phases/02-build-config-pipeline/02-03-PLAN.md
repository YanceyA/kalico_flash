---
phase: 02-build-config-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - klipper-flash/flash.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Running a build cycle copies cached .config into klipper directory, launches menuconfig, then caches the result back"
    - "If .config MCU type does not match device registry entry, the tool refuses to proceed with a clear error message"
  artifacts:
    - path: "klipper-flash/flash.py"
      provides: "cmd_build orchestrator function wiring config.py and build.py"
      contains: "from config import ConfigManager"
    - path: "klipper-flash/flash.py"
      provides: "MCU validation before build"
      contains: "validate_mcu"
  key_links:
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/config.py"
      via: "import ConfigManager"
      pattern: "from config import ConfigManager"
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/build.py"
      via: "import run_menuconfig, run_build"
      pattern: "from build import"
    - from: "cmd_build"
      to: "ConfigManager.validate_mcu"
      via: "function call before build"
      pattern: "validate_mcu.*device\\.mcu"
---

<objective>
Wire config.py and build.py into flash.py CLI to close Phase 2 gaps

Purpose: Enable users to run a complete build cycle through --device flag instead of "not yet implemented" error
Output: Working cmd_build function that orchestrates load_cached_config -> menuconfig -> save_cached_config -> MCU validation -> build
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-build-config-pipeline/02-VERIFICATION.md

# Existing code to integrate
@klipper-flash/flash.py
@klipper-flash/config.py
@klipper-flash/build.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cmd_build orchestrator function</name>
  <files>klipper-flash/flash.py</files>
  <action>
    Add imports at top of flash.py (after existing imports, in the late import section style used elsewhere):
    ```python
    from config import ConfigManager
    from build import run_menuconfig, run_build
    ```

    Create cmd_build function that orchestrates the complete build cycle:
    ```python
    def cmd_build(registry, device_key: str, out) -> int:
        """Build firmware for a registered device.

        Orchestrates: load cached config -> menuconfig -> save config -> MCU validation -> build
        """
        # Load device entry
        entry = registry.get(device_key)
        if entry is None:
            out.error(f"Device '{device_key}' not found.")
            return 1

        # Load global config for klipper_dir
        data = registry.load()
        if data.global_config is None:
            out.error("Global config not set. Run --add-device first.")
            return 1

        klipper_dir = data.global_config.klipper_dir
        out.info("Build", f"Building firmware for {entry.name} ({entry.mcu})")

        # Initialize config manager
        config_mgr = ConfigManager(device_key, klipper_dir)

        # Step 1: Load cached config (if exists)
        if config_mgr.load_cached_config():
            out.info("Config", f"Loaded cached config for '{device_key}'")
        else:
            out.info("Config", "No cached config found, starting fresh")

        # Step 2: Run menuconfig
        out.info("Config", "Launching menuconfig...")
        ret_code, was_saved = run_menuconfig(klipper_dir, str(config_mgr.klipper_config_path))

        if ret_code != 0:
            out.error(f"menuconfig exited with code {ret_code}")
            return 1

        if not was_saved:
            out.warn("Config was not saved in menuconfig")
            if not out.confirm("Continue build anyway?"):
                out.info("Build", "Cancelled")
                return 0

        # Step 3: Save config to cache
        try:
            config_mgr.save_cached_config()
            out.info("Config", f"Cached config for '{device_key}'")
        except ConfigError as e:
            out.error(f"Failed to cache config: {e}")
            return 1

        # Step 4: MCU validation
        try:
            is_match, actual_mcu = config_mgr.validate_mcu(entry.mcu)
            if not is_match:
                out.error(
                    f"MCU mismatch: config has '{actual_mcu}' but device "
                    f"'{device_key}' expects '{entry.mcu}'"
                )
                out.error("Refusing to build wrong firmware. Fix .config and try again.")
                return 1
            out.info("Config", f"MCU validated: {actual_mcu}")
        except ConfigError as e:
            out.error(f"MCU validation failed: {e}")
            return 1

        # Step 5: Build
        out.info("Build", "Running make clean + make...")
        result = run_build(klipper_dir)

        if not result.success:
            out.error(f"Build failed: {result.error_message}")
            return 1

        # Success
        size_kb = result.firmware_size / 1024 if result.firmware_size else 0
        out.success(
            f"Build complete: {result.firmware_path} ({size_kb:.1f} KB) "
            f"in {result.elapsed_seconds:.1f}s"
        )
        return 0
    ```

    NOTE: The imports should be added inside the function or in a try block to maintain the late-import pattern used elsewhere in flash.py (see lines 126, 177, 314-317). Follow the existing pattern.
  </action>
  <verify>
    - Grep flash.py for "from config import ConfigManager" - should find import
    - Grep flash.py for "def cmd_build" - should find function definition
    - Grep flash.py for "validate_mcu" - should find call in cmd_build
  </verify>
  <done>cmd_build function exists with complete orchestration: config loading, menuconfig, config caching, MCU validation, build execution</done>
</task>

<task type="auto">
  <name>Task 2: Wire --device flag to cmd_build</name>
  <files>klipper-flash/flash.py</files>
  <action>
    Replace the current --device handling block (lines 335-347) that shows "Flash workflow not yet implemented" error:

    OLD (lines 335-347):
    ```python
        # Handle --device flag (flash workflow, RGST-05 validation)
        elif args.device:
            # Validate device exists in registry
            entry = registry.get(args.device)
            if entry is None:
                out.error(
                    f"Device '{args.device}' not found. "
                    "Run --list-devices to see registered devices."
                )
                return 1
            # Device exists, but flash workflow not yet implemented
            out.info("Device", f"Selected: {entry.name} ({entry.mcu})")
            out.error("Flash workflow not yet implemented.")
            return 1
    ```

    NEW:
    ```python
        # Handle --device flag (build workflow)
        elif args.device:
            return cmd_build(registry, args.device, out)
    ```

    The device validation is now done inside cmd_build, so the duplicate check is removed.
  </action>
  <verify>
    - Grep flash.py for "Flash workflow not yet implemented" - should NOT be found
    - Grep flash.py for "cmd_build(registry, args.device" - should be found
  </verify>
  <done>--device flag calls cmd_build instead of showing "not yet implemented" error</done>
</task>

<task type="auto">
  <name>Task 3: Add ConfigError import for error handling</name>
  <files>klipper-flash/flash.py</files>
  <action>
    The cmd_build function catches ConfigError. Ensure ConfigError is imported.

    The existing error import pattern at line 317 is:
    ```python
    from errors import KlipperFlashError
    ```

    Update to also import ConfigError:
    ```python
    from errors import KlipperFlashError, ConfigError
    ```

    Alternatively, the import can be done at the top of cmd_build function to maintain lazy loading pattern.
  </action>
  <verify>
    - Grep flash.py for "ConfigError" - should find import and usage
    - Python syntax check: python -m py_compile klipper-flash/flash.py
  </verify>
  <done>ConfigError is imported and available for exception handling in cmd_build</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Syntax validation:**
   ```bash
   python -m py_compile klipper-flash/flash.py
   ```

2. **Import chain check:**
   ```bash
   cd klipper-flash && python -c "from flash import cmd_build; print('OK')"
   ```

3. **Grep verification:**
   - `grep -n "from config import" flash.py` -> Shows ConfigManager import
   - `grep -n "from build import" flash.py` -> Shows build function imports
   - `grep -n "validate_mcu" flash.py` -> Shows MCU validation call
   - `grep -n "not yet implemented" flash.py` -> Should NOT match

4. **Key wiring confirmed:**
   - flash.py imports config.py (was NOT_WIRED, now WIRED)
   - flash.py imports build.py (was NOT_WIRED, now WIRED)
   - validate_mcu called before build (gap 2 closed)
   - --device flag runs build cycle (gap 1 closed)
</verification>

<success_criteria>
- cmd_build function exists and orchestrates full build cycle
- --device flag calls cmd_build instead of showing error
- MCU validation runs before build execution
- ConfigError is properly imported and handled
- No "Flash workflow not yet implemented" message remains
- Python syntax is valid
</success_criteria>

<output>
After completion, create `.planning/phases/02-build-config-pipeline/02-03-SUMMARY.md`
</output>
