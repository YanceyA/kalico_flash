---
phase: 14-flash-all
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kflash/models.py
  - kflash/build.py
  - kflash/flash.py
autonomous: true

must_haves:
  truths:
    - "cmd_flash_all() builds all devices sequentially with suppressed output, copies firmware per device to temp dir, then flashes all inside single klipper_service_stopped()"
    - "Build or flash failure for one device does not prevent remaining devices from being processed"
    - "Version check compares all MCU versions to host before building; if all match, prompts user to proceed or exit"
    - "All devices must have cached configs or the batch aborts with a clear error listing which devices lack configs"
    - "Post-flash verification polls for each device to reappear as Klipper serial device within 30s"
    - "Summary table prints after batch showing device name, build/flash/verify pass/fail status"
  artifacts:
    - path: "kflash/models.py"
      provides: "BatchDeviceResult dataclass"
      contains: "class BatchDeviceResult"
    - path: "kflash/build.py"
      provides: "quiet parameter on run_build()"
      contains: "quiet"
    - path: "kflash/flash.py"
      provides: "cmd_flash_all() orchestration function"
      contains: "def cmd_flash_all"
  key_links:
    - from: "kflash/flash.py"
      to: "kflash/build.py"
      via: "run_build(quiet=True)"
      pattern: "run_build.*quiet"
    - from: "kflash/flash.py"
      to: "kflash/service.py"
      via: "klipper_service_stopped context manager"
      pattern: "klipper_service_stopped"
    - from: "kflash/flash.py"
      to: "kflash/models.py"
      via: "BatchDeviceResult tracking"
      pattern: "BatchDeviceResult"
---

<objective>
Implement the Flash All batch orchestration: dataclass for tracking per-device results, quiet build mode, and the full cmd_flash_all() function with 5 stages (validate configs, version check, build all, flash all, summary).

Purpose: This is the core logic for flashing all registered devices in one command with minimal Klipper downtime.
Output: BatchDeviceResult dataclass in models.py, quiet param in build.py, cmd_flash_all() in flash.py
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/14-flash-all/14-CONTEXT.md
@.planning/phases/14-flash-all/14-RESEARCH.md
@kflash/models.py
@kflash/build.py
@kflash/flash.py (read cmd_flash for patterns — follow the same late-import and output style)
@kflash/moonraker.py (get_host_klipper_version, get_mcu_versions, is_mcu_outdated, get_mcu_version_for_device)
@kflash/service.py (klipper_service_stopped)
@kflash/flasher.py (flash_device)
@kflash/tui.py (wait_for_device)
@kflash/config.py (ConfigManager)
@kflash/discovery.py (scan_serial_devices, match_device, find_registered_devices)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BatchDeviceResult dataclass and quiet build mode</name>
  <files>kflash/models.py, kflash/build.py</files>
  <action>
**models.py:** Add a `BatchDeviceResult` dataclass after `FlashResult`:

```python
@dataclass
class BatchDeviceResult:
    """Per-device result tracking for Flash All batch operations."""
    device_key: str
    device_name: str
    config_ok: bool = False
    build_ok: bool = False
    flash_ok: bool = False
    verify_ok: bool = False
    error_message: Optional[str] = None
    skipped: bool = False  # User chose to skip (version match)
```

**build.py:** Add `quiet: bool = False` parameter to `run_build()`. When `quiet=True`, pass `capture_output=True` to both `subprocess.run()` calls (make clean and make -j) instead of using inherited stdio. This suppresses compiler output during batch builds. The function signature becomes:

```python
def run_build(klipper_dir: str, timeout: int = TIMEOUT_BUILD, quiet: bool = False) -> BuildResult:
```

Inside each `subprocess.run()` call, add `capture_output=quiet` (when True, captures stdout/stderr; when False, inherits stdio as before). This is backward-compatible — existing callers don't pass `quiet` so behavior is unchanged.

Note: `capture_output=True` is equivalent to `stdout=PIPE, stderr=PIPE`. When quiet=False (default), don't pass capture_output at all so stdio is inherited.

Implementation: Use a dict for the extra kwargs:
```python
pipe_kwargs = {"capture_output": True} if quiet else {}
```
Then spread into each subprocess.run() call: `subprocess.run([...], cwd=..., timeout=..., **pipe_kwargs)`
  </action>
  <verify>Read kflash/models.py and confirm BatchDeviceResult exists with all fields. Read kflash/build.py and confirm run_build accepts quiet parameter and conditionally captures output.</verify>
  <done>BatchDeviceResult dataclass has device_key, device_name, config_ok, build_ok, flash_ok, verify_ok, error_message, skipped fields. run_build() accepts quiet=False and suppresses output when True.</done>
</task>

<task type="auto">
  <name>Task 2: Implement cmd_flash_all() orchestration function</name>
  <files>kflash/flash.py</files>
  <action>
Add `cmd_flash_all(registry, out) -> int` function in flash.py. Follow the same late-import pattern as `cmd_flash()`. The function has 5 stages:

**Stage 1: Validate cached configs**
- Load registry, get all flashable devices (where `entry.flashable is True`). Sort alphabetically by key.
- For each device, check if cached config exists: instantiate `ConfigManager(entry.key, global_config.klipper_dir)` and check `config_mgr.cache_path.exists()`.
- If ANY device lacks a cached config, print an error listing which devices need configuration, and return 1.
- If no flashable devices exist, print error and return 1.

**Stage 2: Version check**
- Import from moonraker: `get_host_klipper_version`, `get_mcu_versions`, `is_mcu_outdated`, `get_mcu_version_for_device`
- Get host version and MCU versions. If Moonraker unavailable (returns None): print warning "Version check unavailable — Moonraker not reachable. Flashing all devices.", set flash_list = all devices, skip all version prompts entirely, and jump straight to Stage 3.
- For each device, check if MCU version matches host version using `is_mcu_outdated()`.
- If ALL devices match host version: prompt "All devices already match host version. Flash anyway? [y/N]" — if user says no, return 0.
- If SOME match, SOME don't: show which are outdated vs current, prompt "Flash only outdated devices? [Y/n]" — if yes, filter to outdated only; if no, flash all.
- Store the final device list to flash.

**Stage 3: Build all firmware**
- Use `tempfile.mkdtemp(prefix="kalico-flash-")` for firmware copies.
- For each device in the flash list:
  - Print: `"Building {i+1}/{total}: {entry.name}..."`
  - Load cached config: `ConfigManager(entry.key, global_config.klipper_dir).load_cached_config()` (takes no parameters — it uses cache_path and klipper_dir from __init__).
  - Run build: `run_build(klipper_dir, quiet=True)`
  - If success: copy firmware from `klipper_dir/out/klipper.bin` to `{temp_dir}/{entry.key}/klipper.bin` using shutil.copy2. Print `"✓ {entry.name} built ({i+1}/{total})"`.
  - If failure: record in BatchDeviceResult, print `"✗ {entry.name} build failed ({i+1}/{total})"`, continue to next.
- After all builds, check if any succeeded. If none, clean up temp dir and return 1.

**Stage 4: Flash all (inside single service stop)**
- Filter to only devices that built successfully.
- Print safety check: call `get_print_status()` from moonraker — if printing, abort with warning.
- Verify passwordless sudo before entering service stop.
- Use `with klipper_service_stopped(out=out):` context manager.
- Inside: re-scan USB devices with `scan_serial_devices()` (paths may change after Klipper stops).
- For each device with successful build:
  - If not first device: `time.sleep(stagger_delay)` using `global_config.stagger_delay`.
  - Find device by pattern using discovery module's match function.
  - If device not found: mark failed, continue.
  - Flash using `flash_device()` with the firmware copy path from temp dir.
  - If flash succeeds: run `wait_for_device(entry.serial_pattern, timeout=30.0)` for verification.
  - Print tally: `"✓ {entry.name} flashed ({i+1}/{total})"` or `"✗ {entry.name} flash failed ({i+1}/{total})"`.
- After context manager exits (Klipper restarted), clean up temp dir with `shutil.rmtree()`.

**Stage 5: Summary table**
- Print a summary table with columns: Device, Build, Flash, Verify.
- For each BatchDeviceResult:
  - Build: "PASS" or "FAIL"
  - Flash: "PASS", "FAIL", or "SKIP" (if build failed or device skipped)
  - Verify: "PASS", "FAIL", or "SKIP" (if flash failed/skipped)
- Use `out.info()` for table rows. Print total pass/fail counts.
- Return 0 if all devices passed, 1 if any failed.

**Important implementation details:**
- Use late imports (same pattern as cmd_flash).
- Use `input()` for Y/N prompts (same pattern as existing code — check how cmd_flash does confirmations).
- The function takes `registry` and `out` as parameters (same as other cmd_* functions).
- Use `print()` for progress lines (build tally, flash tally) since these are transient status, not phase-labeled output.
- Wrap the entire function in try/finally to ensure temp dir cleanup.
  </action>
  <verify>Read kflash/flash.py and confirm cmd_flash_all() exists with all 5 stages. Verify it uses late imports, handles continue-on-failure, uses single klipper_service_stopped(), copies firmware to temp dir, and prints summary table.</verify>
  <done>cmd_flash_all() implements all 5 stages: config validation, version check with selective flash prompt, sequential quiet builds with firmware copies, single-stop flash with stagger delay and verification, and summary table with pass/fail status.</done>
</task>

</tasks>

<verification>
1. `BatchDeviceResult` dataclass exists in models.py with all required fields
2. `run_build()` accepts `quiet=False` parameter and suppresses output when True
3. `cmd_flash_all()` exists in flash.py with 5 stages
4. Build failures don't prevent other devices from building or flashing
5. Flash failures don't prevent remaining devices from flashing
6. Firmware copied to temp dir after each build (avoids path collision)
7. Single `klipper_service_stopped()` wraps all flash operations
8. USB devices re-scanned after Klipper stop
9. Post-flash verification uses `wait_for_device()` with 30s timeout
10. Summary table printed after batch completes
</verification>

<success_criteria>
cmd_flash_all() can be called with a registry and output interface, validates configs, checks versions, builds all firmware quietly, flashes inside single service stop with stagger delay, verifies each device, and prints a summary table. One device failure never blocks others.
</success_criteria>

<output>
After completion, create `.planning/phases/14-flash-all/14-01-SUMMARY.md`
</output>
