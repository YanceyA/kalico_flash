---
phase: 23-tui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [kflash/tui.py]
autonomous: true

must_haves:
  truths:
    - "Pressing K in device config screen initiates Katapult check for the selected device"
    - "Warning message explains device will briefly enter bootloader mode before user confirms"
    - "Confirmation prompt defaults to No — user must actively opt in"
    - "Result displayed clearly: Katapult detected / not detected / inconclusive with explanation"
    - "Klipper service stopped before check, guaranteed restart after"
  artifacts:
    - path: "kflash/tui.py"
      provides: "K key handler in _device_config_screen"
      contains: "elif key == \"k\""
  key_links:
    - from: "kflash/tui.py"
      to: "kflash/flasher.check_katapult"
      via: "import and call inside K handler"
      pattern: "check_katapult"
    - from: "kflash/tui.py"
      to: "kflash/service.klipper_service_stopped"
      via: "context manager wrapping check"
      pattern: "klipper_service_stopped"
---

<objective>
Wire the "K" key handler into the device config screen to let users check for Katapult bootloader presence on the selected device.

Purpose: Completes the TUI integration for Katapult detection — users can check from the device config screen with safety gates (warning, confirmation, service lifecycle).
Output: Modified `kflash/tui.py` with K key handler in `_device_config_screen()`.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-tui-integration/23-RESEARCH.md

@kflash/tui.py (device config screen, key dispatch loop)
@kflash/flasher.py (check_katapult function)
@kflash/service.py (klipper_service_stopped context manager)
@kflash/models.py (KatapultCheckResult dataclass)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add "K" key handler in _device_config_screen</name>
  <files>kflash/tui.py</files>
  <action>
In `_device_config_screen()`, add a new `elif key == "k":` branch in the key dispatch loop. Place it after the numbered setting handlers (1-5) and before the escape/return handlers.

The handler must follow this exact sequence:

1. **Print the key** (matching existing pattern): `print(key)` then `print()`
2. **Check device connection**: Import `scan_serial_devices` and `match_devices` from `.discovery`. Get the device entry from registry via `original_key`. Call `scan_serial_devices()` then `match_devices(entry.serial_pattern, usb_devices)`. If no matches, print error `"Device not connected. Cannot check Katapult."` using `theme.error`, show "Press Enter to continue...", then `continue`.
3. **Get device_path**: `matches[0].path`
4. **Display warning**: Two lines using `theme.warning`:
   - `"Warning: This will briefly put the device into bootloader mode."`
   - `"The device will be recovered automatically afterward."`
5. **Confirmation prompt**: `input()` with `"Proceed with Katapult check? (y/N):"` using `theme.prompt`. Wrap in try/except for EOFError and KeyboardInterrupt (default to "n"). If answer not in `("y", "yes")`, `continue`.
6. **Load global config**: `gc = registry.load_global()` to get `katapult_dir`.
7. **Define log callback**: `log_fn(msg)` that prints with `theme.info` prefix.
8. **Execute with service lifecycle**: Import `klipper_service_stopped` from `.service` and `check_katapult` from `.flasher`. Wrap in try/except for general Exception. Inside `with klipper_service_stopped(out=out):`, call `check_katapult(device_path=device_path, serial_pattern=entry.serial_pattern, katapult_dir=gc.katapult_dir, log=log_fn)`.
9. **Display result** (tri-state):
   - `has_katapult is True`: green success `"Katapult bootloader detected (Xs)"` with `result.elapsed_seconds`
   - `has_katapult is False`: info `"No Katapult bootloader detected (Xs)"`
   - `has_katapult is None`: warning `"Inconclusive: {result.error_message}"`
10. **Wait for Enter**: `input("  Press Enter to continue...")`

Also update the prompt text in the device config screen to include a "K" hint so users know the key is available. Add `K=Check Katapult` to the prompt line that currently shows setting numbers and Esc/B hint.

See the research file's "Complete K Key Handler" code example for the full implementation pattern.
  </action>
  <verify>
  - `grep -n 'elif key == "k"' kflash/tui.py` finds the new handler
  - `grep -n 'check_katapult' kflash/tui.py` confirms the import and call
  - `grep -n 'klipper_service_stopped' kflash/tui.py` confirms service lifecycle wrapping
  - `grep -n 'y/N' kflash/tui.py` confirms default-No confirmation
  - `grep -n 'Katapult' kflash/tui.py` shows warning, result display lines
  - `python -c "import kflash.tui"` succeeds (syntax check)
  </verify>
  <done>
  - K key handler exists in _device_config_screen key dispatch
  - Device connection checked before proceeding
  - Warning displayed about bootloader mode
  - Confirmation defaults to No
  - check_katapult called inside klipper_service_stopped context manager
  - Tri-state result displayed with appropriate theme colors
  - Prompt text includes K hint
  </done>
</task>

</tasks>

<verification>
1. `python -c "import kflash.tui"` — no import errors
2. Grep for key integration points: check_katapult, klipper_service_stopped, "y/N", elif key == "k"
3. On Pi: `python3 flash.py` — navigate to device config screen, verify "K" hint visible in prompt
4. On Pi: Press K with device connected — verify warning, confirmation, service stop, check, result display, service restart
5. On Pi: Press K with device disconnected — verify "Device not connected" error
6. On Pi: Press K then answer "n" — verify returns to config screen without action
</verification>

<success_criteria>
All five TUI requirements (TUI-01 through TUI-05) satisfied:
- K key triggers Katapult check (TUI-01)
- Warning about bootloader mode (TUI-02)
- Default-No confirmation (TUI-03)
- Clear tri-state result display (TUI-04)
- Service lifecycle guaranteed (TUI-05)
</success_criteria>

<output>
After completion, create `.planning/phases/23-tui-integration/23-01-SUMMARY.md`
</output>
