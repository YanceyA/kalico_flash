---
phase: 24-slug-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [kflash/validation.py]
autonomous: true

must_haves:
  truths:
    - "generate_device_key('Octopus Pro v1.1', registry) returns 'octopus-pro-v1-1'"
    - "When slug collides with existing key, numeric suffix -2, -3 is appended until unique"
    - "Empty result after normalization raises ValueError"
    - "Long names truncated to 64 chars with clean hyphen edges"
    - "Path-traversal characters (/, \\, ..) stripped by character filter"
  artifacts:
    - path: "kflash/validation.py"
      provides: "generate_device_key() function"
      contains: "def generate_device_key"
  key_links:
    - from: "kflash/validation.py:generate_device_key"
      to: "registry.get()"
      via: "collision check loop"
      pattern: "registry\\.get\\(candidate\\)"
---

<objective>
Add `generate_device_key()` to validation.py that converts display names to unique filesystem-safe slug keys with collision handling.

Purpose: Phase 25 will wire this into the add-device wizard, removing the manual key prompt. This phase builds and tests the pure function.
Output: `generate_device_key(name, registry)` in kflash/validation.py
</objective>

<context>
@.planning/ROADMAP.md (Phase 24 success criteria)
@.planning/REQUIREMENTS.md (KEY-01, KEY-02)
@.planning/phases/24-slug-generation/24-RESEARCH.md
@kflash/validation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_device_key() with slugification and collision handling</name>
  <files>kflash/validation.py</files>
  <action>
Add `generate_device_key(name: str, registry) -> str` to kflash/validation.py. Add `import unicodedata` and `from itertools import count` at the top.

Implementation steps (in order):
1. `unicodedata.normalize('NFKD', name)` for Unicode decomposition
2. `.encode('ascii', 'ignore').decode('ascii')` to drop non-ASCII
3. `.lower()`, replace spaces and underscores with hyphens
4. `re.sub(r'[^a-z0-9-]', '', slug)` to strip everything except alphanumeric and hyphens
5. `re.sub(r'-+', '-', slug)` to collapse consecutive hyphens
6. `.strip('-')` then truncate to 64 chars, then `.rstrip('-')` again
7. Raise `ValueError` if slug is empty after all normalization
8. Loop with `itertools.count(2)`: check `registry.get(candidate)`, if None return it, else build candidate as `slug[:64 - len(suffix_str)] + suffix_str` where `suffix_str = f"-{n}"`

Place the function AFTER `validate_device_key()` (end of file). Use the same docstring style as existing functions in the module. Include examples in docstring: "Octopus Pro v1.1" -> "octopus-pro-v1-1", "Cafe MCU" -> "cafe-mcu".

Do NOT modify any existing functions.
  </action>
  <verify>
On the Pi, run a quick smoke test:
```bash
ssh yanceya@192.168.50.50 "cd ~/kalico-flash && python3 -c \"
from kflash.validation import generate_device_key
from kflash.registry import Registry
r = Registry('devices.json')

# Basic slug
assert generate_device_key('Octopus Pro v1.1', r) == 'octopus-pro-v1-1', 'basic slug failed'

# Special chars
assert generate_device_key('Device!!!', r) == 'device', 'special chars failed'

# Hyphen collapse
assert generate_device_key('A - - B', r) == 'a-b', 'hyphen collapse failed'

# Long name truncation
long = 'A' * 100
slug = generate_device_key(long, r)
assert len(slug) <= 64, 'truncation failed'

# Empty raises ValueError
try:
    generate_device_key('!!!', r)
    assert False, 'should have raised'
except ValueError:
    pass

# Collision handling (octopus-pro already exists in registry)
existing = r.get('octopus-pro')
if existing:
    result = generate_device_key('Octopus Pro', r)
    assert result == 'octopus-pro-2', f'collision failed: got {result}'

print('All tests passed')
\""
```
  </verify>
  <done>
- generate_device_key("Octopus Pro v1.1", registry) returns "octopus-pro-v1-1"
- Collision with existing key appends -2, -3 suffix
- Empty slug raises ValueError
- Long names truncated to 64 chars
- Path-traversal characters stripped
- Existing validate_device_key() and other functions unchanged
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "from kflash.validation import generate_device_key"` imports without error
2. Smoke tests above pass on Pi
3. `python3 flash.py --list-devices` still works (no regression)
</verification>

<success_criteria>
- generate_device_key() exists in validation.py and handles all cases from Phase 24 success criteria
- No external dependencies added
- Existing functions in validation.py unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/24-slug-generation/24-01-SUMMARY.md`
</output>
