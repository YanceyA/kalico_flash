---
phase: 22-core-detection-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - kflash/models.py
  - kflash/flasher.py
autonomous: true

must_haves:
  truths:
    - "check_katapult() returns KatapultCheckResult with tri-state (True/False/None) and error context"
    - "Bootloader entry uses flashtool.py -r, polls for katapult_ device appearance"
    - "If Katapult not found, sysfs USB reset recovers device to Klipper_ serial"
    - "Helper functions are independently callable with clear single responsibilities"
    - "Timing constants match Phase 21 research values"
  artifacts:
    - path: "kflash/models.py"
      provides: "KatapultCheckResult dataclass"
      contains: "class KatapultCheckResult"
    - path: "kflash/flasher.py"
      provides: "check_katapult function and 3 helper functions"
      exports: ["check_katapult"]
  key_links:
    - from: "kflash/flasher.py"
      to: "kflash/models.py"
      via: "KatapultCheckResult import"
      pattern: "from .models import.*KatapultCheckResult"
    - from: "check_katapult"
      to: "_poll_for_serial_device"
      via: "function call after flashtool.py -r"
      pattern: "_poll_for_serial_device"
    - from: "check_katapult"
      to: "_usb_sysfs_reset"
      via: "recovery path when Katapult not found"
      pattern: "_usb_sysfs_reset"
---

<objective>
Implement the core Katapult bootloader detection engine: KatapultCheckResult dataclass, three helper functions, and the main check_katapult() orchestrator.

Purpose: Provides reusable detection logic that Phase 23 will wire into the TUI device config screen.
Output: KatapultCheckResult in models.py, check_katapult() + helpers in flasher.py.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-pi-hardware-research/21-01-SUMMARY.md
@kflash/models.py
@kflash/flasher.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: KatapultCheckResult dataclass and timing constants</name>
  <files>kflash/models.py, kflash/flasher.py</files>
  <action>
1. In models.py, add KatapultCheckResult dataclass after FlashResult:

```python
@dataclass
class KatapultCheckResult:
    """Result of a Katapult bootloader detection check.

    has_katapult is tri-state:
      True  - Katapult bootloader detected (katapult_ device appeared)
      False - No Katapult (device entered DFU/BOOTSEL, recovered via USB reset)
      None  - Inconclusive (error during check, device state unknown)
    """
    has_katapult: Optional[bool]  # True/False/None tri-state
    error_message: Optional[str] = None  # Details when None or False
    elapsed_seconds: float = 0.0
```

2. In flasher.py, add timing constants after the existing TIMEOUT_FLASH constant:

```python
# Katapult detection timing (from Phase 21 hardware research)
BOOTLOADER_ENTRY_TIMEOUT = 5.0   # Max wait for flashtool.py -r
USB_RESET_SLEEP = 0.5            # Pause between deauthorize/reauthorize
POLL_INTERVAL = 0.25             # Serial device polling interval
POLL_TIMEOUT = 5.0               # Max wait for device reappearance
```

3. Update the flasher.py import to include KatapultCheckResult:
```python
from .models import FlashResult, KatapultCheckResult
```
  </action>
  <verify>python3 -c "from kflash.models import KatapultCheckResult; r = KatapultCheckResult(has_katapult=True); print(r)"</verify>
  <done>KatapultCheckResult dataclass importable with tri-state has_katapult field. Four timing constants defined in flasher.py.</done>
</task>

<task type="auto">
  <name>Task 2: Three helper functions</name>
  <files>kflash/flasher.py</files>
  <action>
Add three private helper functions in flasher.py, ABOVE check_katapult but BELOW the existing flash functions. Each must be independently callable.

1. **_resolve_usb_sysfs_path(serial_path: str) -> str**
   - Takes /dev/serial/by-id/ path
   - Returns path to sysfs `authorized` file for the USB device
   - Algorithm from Phase 21 research: realpath -> tty name -> /sys/class/tty/{name}/device -> realpath -> parent dir -> authorized
   - Raise DiscoveryError if any step fails (symlink broken, sysfs path missing)

```python
def _resolve_usb_sysfs_path(serial_path: str) -> str:
    """Resolve /dev/serial/by-id/ symlink to sysfs USB authorized file path."""
    import os
    real_dev = os.path.realpath(serial_path)
    tty_name = os.path.basename(real_dev)
    sysfs_device = f"/sys/class/tty/{tty_name}/device"
    if not os.path.exists(sysfs_device):
        raise DiscoveryError(f"sysfs path not found: {sysfs_device}")
    iface_path = os.path.realpath(sysfs_device)
    usb_dev_path = os.path.dirname(iface_path)
    authorized = os.path.join(usb_dev_path, "authorized")
    if not os.path.exists(authorized):
        raise DiscoveryError(f"USB authorized file not found: {authorized}")
    return authorized
```

2. **_usb_sysfs_reset(authorized_path: str) -> None**
   - Writes '0' then '1' to authorized file with USB_RESET_SLEEP between
   - Uses sudo via subprocess (MainsailOS has passwordless sudo)
   - Raise DiscoveryError on failure

```python
def _usb_sysfs_reset(authorized_path: str) -> None:
    """Toggle USB device authorized flag to force re-enumeration."""
    for value in ('0', '1'):
        result = subprocess.run(
            ['sudo', 'tee', authorized_path],
            input=value,
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            raise DiscoveryError(
                f"Failed to write '{value}' to {authorized_path}: "
                f"{result.stderr.strip()}"
            )
        if value == '0':
            time.sleep(USB_RESET_SLEEP)
```

3. **_poll_for_serial_device(pattern: str, timeout: float = POLL_TIMEOUT) -> Optional[str]**
   - Polls /dev/serial/by-id/ for a device matching the glob pattern
   - Returns full path if found, None if timeout
   - Uses POLL_INTERVAL between checks
   - Pattern should be like "usb-*_stm32h723xx_29001A*" (fnmatch glob)

```python
def _poll_for_serial_device(
    pattern: str,
    timeout: float = POLL_TIMEOUT,
) -> Optional[str]:
    """Poll /dev/serial/by-id/ for device matching glob pattern."""
    import fnmatch
    import os
    serial_dir = '/dev/serial/by-id'
    deadline = time.monotonic() + timeout
    while time.monotonic() < deadline:
        try:
            for name in os.listdir(serial_dir):
                if fnmatch.fnmatch(name, pattern):
                    return os.path.join(serial_dir, name)
        except FileNotFoundError:
            pass  # Directory may vanish briefly during USB reset
        time.sleep(POLL_INTERVAL)
    return None
```

Import os at the top of the file (add to existing imports). Import fnmatch inside the function that uses it (or at top -- either is fine).
  </action>
  <verify>Run on Pi via SSH: ssh yanceya@192.168.50.50 "cd ~/kalico-flash && python3 -c \"from kflash.flasher import _resolve_usb_sysfs_path, _usb_sysfs_reset, _poll_for_serial_device; print('helpers imported')\""</verify>
  <done>Three helper functions exist in flasher.py. _resolve_usb_sysfs_path resolves serial symlink to sysfs authorized path. _usb_sysfs_reset toggles authorized flag with sudo. _poll_for_serial_device polls with fnmatch glob matching.</done>
</task>

<task type="auto">
  <name>Task 3: check_katapult() orchestrator function</name>
  <files>kflash/flasher.py</files>
  <action>
Add the main check_katapult() function after the three helpers. This is a PUBLIC function (no underscore prefix) that orchestrates the full detection flow.

**Function signature:**
```python
def check_katapult(
    device_path: str,
    serial_pattern: str,
    katapult_dir: str,
    log: Optional[Callable[[str], None]] = None,
) -> KatapultCheckResult:
```

**Parameters:**
- device_path: Current /dev/serial/by-id/ path (Klipper_ device)
- serial_pattern: Glob pattern from DeviceEntry.serial_pattern (e.g., "usb-Klipper_stm32h723xx_29001A*")
- katapult_dir: Path to Katapult source (for flashtool.py)
- log: Optional callback for progress messages

**Algorithm:**
1. Record start time
2. Extract serial substring from device_path filename using regex: `usb-(?:Klipper|katapult)_[a-zA-Z0-9]+_([A-Fa-f0-9]+)` -- if no match, return KatapultCheckResult(has_katapult=None, error_message="Could not extract serial from device path")
3. Resolve sysfs authorized path via _resolve_usb_sysfs_path(device_path) -- wrap in try/except, return None result on failure
4. Build flashtool path: katapult_dir/scripts/flashtool.py -- if not exists, return None result
5. Log "Entering bootloader mode..." if log provided
6. Run flashtool.py -r: `subprocess.run(["python3", str(flashtool), "-r", "-d", device_path], capture_output=True, text=True, timeout=BOOTLOADER_ENTRY_TIMEOUT)`
   - If returncode != 0, return KatapultCheckResult(has_katapult=None, error_message=stderr)
7. Build katapult poll pattern from serial substring: `usb-katapult_*_{serial}*` (the serial hex is the stable identifier across modes)
8. Log "Polling for Katapult device..." if log provided
9. Poll for katapult device: `_poll_for_serial_device(katapult_pattern)`
   - If found: return KatapultCheckResult(has_katapult=True, elapsed_seconds=elapsed)
10. If NOT found (timeout): Katapult not installed, device likely in DFU/BOOTSEL
    - Log "No Katapult detected, recovering device..." if log provided
    - Call _usb_sysfs_reset(authorized_path) -- wrap in try/except
    - Build klipper poll pattern from serial_pattern (the original pattern)
    - Poll for klipper device return: _poll_for_serial_device(serial_pattern)
    - If klipper device returns: return KatapultCheckResult(has_katapult=False, elapsed_seconds=elapsed)
    - If klipper device does NOT return: return KatapultCheckResult(has_katapult=None, error_message="Device did not recover after USB reset", elapsed_seconds=elapsed)

**Error handling:** Every external operation (subprocess, file I/O, sysfs) must be wrapped in try/except. Never let an exception escape -- always return a KatapultCheckResult with has_katapult=None and descriptive error_message.

**Import re at module top** for the serial extraction regex.
  </action>
  <verify>Run on Pi: ssh yanceya@192.168.50.50 "cd ~/kalico-flash && python3 -c \"from kflash.flasher import check_katapult; print(check_katapult.__doc__[:50])\""</verify>
  <done>check_katapult() is importable, accepts (device_path, serial_pattern, katapult_dir, log), returns KatapultCheckResult. Handles all three outcomes: True (Katapult found), False (no Katapult, recovered), None (error/inconclusive). All exceptions caught internally.</done>
</task>

</tasks>

<verification>
1. `python3 -c "from kflash.models import KatapultCheckResult; print(KatapultCheckResult(has_katapult=True))"` -- imports and instantiates
2. `python3 -c "from kflash.flasher import check_katapult, _resolve_usb_sysfs_path, _usb_sysfs_reset, _poll_for_serial_device; print('all functions importable')"` -- all 4 functions exist
3. `python3 -c "from kflash.flasher import BOOTLOADER_ENTRY_TIMEOUT, USB_RESET_SLEEP, POLL_INTERVAL, POLL_TIMEOUT; assert POLL_INTERVAL == 0.25; assert POLL_TIMEOUT == 5.0; print('constants OK')"` -- timing constants correct
4. Verify on Pi with SCP + SSH that module loads without import errors
</verification>

<success_criteria>
- KatapultCheckResult dataclass in models.py with tri-state has_katapult (True/False/None)
- Four timing constants in flasher.py matching Phase 21 research
- _resolve_usb_sysfs_path() resolves serial symlink to sysfs authorized file
- _usb_sysfs_reset() toggles authorized with sudo and sleep
- _poll_for_serial_device() polls with fnmatch glob and timeout
- check_katapult() orchestrates full flow: flashtool -r -> poll katapult -> (if not found) sysfs reset -> poll klipper recovery
- All exceptions caught internally, never escapes check_katapult()
</success_criteria>

<output>
After completion, create `.planning/phases/22-core-detection-engine/22-01-SUMMARY.md`
</output>
