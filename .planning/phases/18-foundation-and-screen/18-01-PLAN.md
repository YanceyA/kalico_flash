---
phase: 18-foundation-and-screen
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [kflash/registry.py, kflash/validation.py, kflash/config.py]
autonomous: true

must_haves:
  truths:
    - "Registry.update_device() atomically updates a device entry (load-modify-save)"
    - "validate_device_key() rejects empty keys, invalid characters, and duplicate keys"
    - "rename_device_config_cache() moves config cache directory when key changes"
  artifacts:
    - path: "kflash/registry.py"
      provides: "update_device method"
      contains: "def update_device"
    - path: "kflash/validation.py"
      provides: "Device key validation"
      contains: "def validate_device_key"
    - path: "kflash/config.py"
      provides: "Config cache rename helper"
      contains: "def rename_device_config_cache"
  key_links:
    - from: "kflash/registry.py"
      to: "_atomic_write_json"
      via: "self.save() in update_device"
      pattern: "self\\.save\\(registry\\)"
    - from: "kflash/validation.py"
      to: "kflash/registry.py"
      via: "registry.get() for uniqueness check"
      pattern: "registry\\.get\\("
---

<objective>
Add backend persistence and validation primitives for device config editing: Registry.update_device() method, device key validation function, and config cache rename helper.

Purpose: Phase 18 foundation — these methods are consumed by the device config screen (Plan 02) and the edit interaction loop (Phase 19).
Output: Three new functions in existing modules, no new files.
</objective>

<context>
@.planning/phases/18-foundation-and-screen/18-RESEARCH.md
@kflash/registry.py
@kflash/validation.py
@kflash/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Registry update_device method and key validation</name>
  <files>kflash/registry.py, kflash/validation.py</files>
  <action>
  In `kflash/registry.py`, add `update_device(self, key: str, **updates) -> bool` method to the Registry class, after `set_flashable`. Pattern mirrors `save_global` and `set_flashable`: load registry, check key exists, setattr each update field on the DeviceEntry, save registry atomically. Return False if key not found.

  In `kflash/validation.py`, add `validate_device_key(key: str, registry, current_key: str = None) -> tuple[bool, str]` function. Import `re` at top of file. Rules:
  - Strip whitespace first
  - Reject empty string: "Device key cannot be empty"
  - Regex `^[a-z0-9][a-z0-9_-]*$` — reject with message about valid characters
  - If current_key provided and key == current_key, return True (self-rename is no-op)
  - Check `registry.get(key) is not None` — reject with "Device '{key}' already registered"
  - Return (True, "") on success
  </action>
  <verify>
  Read both files and confirm:
  - `update_device` follows load-modify-save pattern with `self.save(registry)` call
  - `validate_device_key` has all 4 checks (empty, regex, self-match, uniqueness)
  - No new imports beyond `re` in validation.py
  </verify>
  <done>Registry has update_device method; validation.py has validate_device_key function with empty/format/uniqueness checks</done>
</task>

<task type="auto">
  <name>Task 2: Config cache rename helper</name>
  <files>kflash/config.py</files>
  <action>
  In `kflash/config.py`, add `rename_device_config_cache(old_key: str, new_key: str) -> bool` function after `get_config_dir`. Add `import shutil` at top of file if not already present.

  Implementation:
  - Get old_dir via `get_config_dir(old_key)`, new_dir via `get_config_dir(new_key)`
  - If old_dir doesn't exist, return False (no cache to rename)
  - If new_dir already exists, raise `FileExistsError(f"Config cache for '{new_key}' already exists")`
  - Create parent of new_dir with `mkdir(parents=True, exist_ok=True)`
  - Use `shutil.move(str(old_dir), str(new_dir))` for cross-filesystem safety
  - Return True
  </action>
  <verify>
  Read config.py and confirm:
  - Function exists with correct signature
  - Uses `shutil.move` (not `os.rename`)
  - Checks old_dir existence and new_dir non-existence
  </verify>
  <done>Config cache rename helper exists, uses shutil.move, handles edge cases (no cache, target exists)</done>
</task>

</tasks>

<verification>
- `grep -n "def update_device" kflash/registry.py` shows method exists
- `grep -n "def validate_device_key" kflash/validation.py` shows function exists
- `grep -n "def rename_device_config_cache" kflash/config.py` shows function exists
- `python -c "from kflash.registry import Registry; from kflash.validation import validate_device_key; from kflash.config import rename_device_config_cache"` imports succeed
</verification>

<success_criteria>
- Registry.update_device() atomically updates device fields via load-modify-save
- validate_device_key() rejects empty, invalid chars, duplicates; allows self-rename
- rename_device_config_cache() moves cache dir with shutil.move, returns False if no cache
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-and-screen/18-01-SUMMARY.md`
</output>
