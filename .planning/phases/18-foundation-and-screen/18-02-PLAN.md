---
phase: 18-foundation-and-screen
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [kflash/screen.py]
autonomous: true

must_haves:
  truths:
    - "Device config screen renders read-only identity panel with MCU type and serial pattern"
    - "Device config screen renders numbered editable settings panel with current values"
    - "Screen follows two-panel visual pattern matching existing global config screen"
  artifacts:
    - path: "kflash/screen.py"
      provides: "DEVICE_SETTINGS list and render_device_config_screen function"
      contains: "DEVICE_SETTINGS"
    - path: "kflash/screen.py"
      provides: "Device config screen renderer"
      contains: "def render_device_config_screen"
  key_links:
    - from: "kflash/screen.py"
      to: "panels.render_panel"
      via: "render_panel calls for identity and settings panels"
      pattern: "render_panel\\("
    - from: "kflash/screen.py"
      to: "kflash/models.py"
      via: "DeviceEntry import for type hint and getattr"
      pattern: "DeviceEntry"
---

<objective>
Create the device config screen rendering: DEVICE_SETTINGS definition and render_device_config_screen() function producing two-panel output (identity + settings).

Purpose: Visual rendering for device config screen, consumed by Phase 19 interaction loop.
Output: DEVICE_SETTINGS list and render_device_config_screen() in screen.py.
</objective>

<context>
@.planning/phases/18-foundation-and-screen/18-RESEARCH.md
@kflash/screen.py (see render_config_screen and SETTINGS for the pattern to follow)
@kflash/models.py (DeviceEntry dataclass)
@kflash/panels.py (render_panel function)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DEVICE_SETTINGS list and render_device_config_screen function</name>
  <files>kflash/screen.py</files>
  <action>
  In `kflash/screen.py`, add a new section after the config screen rendering section. Add import for DeviceEntry from models if not present.

  Define `DEVICE_SETTINGS` list (mirrors `SETTINGS` pattern):
  ```python
  DEVICE_SETTINGS: list[dict] = [
      {"key": "name", "label": "Display name", "type": "text"},
      {"key": "key", "label": "Device key", "type": "text"},
      {"key": "flash_method", "label": "Flash method", "type": "cycle", "values": [None, "katapult", "make_flash"]},
      {"key": "flashable", "label": "Include in flash operations", "type": "toggle"},
      {"key": "menuconfig", "label": "Edit firmware config", "type": "action"},
  ]
  ```

  Define `render_device_config_screen(device_entry: DeviceEntry) -> str`:
  - Get theme via `get_theme()`
  - Panel 1 — "device identity" (read-only):
    - Line: `MCU Type: {device_entry.mcu}`
    - Line: `Serial Pattern: {device_entry.serial_pattern}`
    - Use `render_panel("device identity", identity_lines)`
  - Panel 2 — "settings" (numbered, editable):
    - For each setting in DEVICE_SETTINGS, numbered starting at 1:
      - Use `getattr(device_entry, setting["key"])` for all fields (DeviceEntry has .key field)
      - For "toggle": display "ON" if value else "OFF"
      - For "cycle": display value if truthy else "default"
      - For "action": display triangle marker (use same subtle style)
      - For "text": display str(value)
    - Format each line: `{i}. {label}: {display_value}` using theme colors matching render_config_screen pattern
    - Use `render_panel("settings", settings_lines)`
  - Return panels joined with "\n\n"

  Follow the exact formatting pattern from `render_config_screen`: `{theme.label}{i}.{theme.reset} {theme.text}{label}:{theme.reset} {theme.value}{display}{theme.reset}`
  </action>
  <verify>
  Read screen.py and confirm:
  - DEVICE_SETTINGS has 5 entries with correct keys/types
  - render_device_config_screen accepts device_entry param only (DeviceEntry has .key field)
  - Two render_panel calls: "device identity" and "settings"
  - Numbered settings follow same formatting as render_config_screen
  - All settings use getattr(device_entry, setting["key"])
  </verify>
  <done>DEVICE_SETTINGS defined with 5 settings; render_device_config_screen produces two-panel output (identity read-only + settings numbered) matching global config screen visual pattern</done>
</task>

</tasks>

<verification>
- `grep -n "DEVICE_SETTINGS" kflash/screen.py` shows list definition
- `grep -n "def render_device_config_screen" kflash/screen.py` shows function
- `grep -c "render_panel" kflash/screen.py` count increases by 2 (identity + settings panels)
- `python -c "from kflash.screen import render_device_config_screen, DEVICE_SETTINGS; print(len(DEVICE_SETTINGS))"` prints 5
</verification>

<success_criteria>
- DEVICE_SETTINGS list defines 5 settings (name, key, flash_method, flashable, menuconfig)
- render_device_config_screen produces identity panel (MCU, serial) + settings panel (numbered)
- Visual format matches existing render_config_screen two-panel pattern
</success_criteria>

<output>
After completion, create `.planning/phases/18-foundation-and-screen/18-02-SUMMARY.md`
</output>
