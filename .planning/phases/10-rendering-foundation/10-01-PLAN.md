---
phase: 10-rendering-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [kflash/theme.py, kflash/ansi.py]
autonomous: true

must_haves:
  truths:
    - "Theme detects truecolor, 256-color, ANSI 16, or no-color tier automatically based on terminal environment"
    - "strip_ansi() removes all CSI escape sequences from any string"
    - "display_width() returns visible character count ignoring ANSI codes and handling CJK wide chars"
    - "pad_to_width() pads to exact visible width regardless of embedded ANSI codes"
    - "get_terminal_width() returns current terminal width at call time, clamped to minimum"
  artifacts:
    - path: "kflash/theme.py"
      provides: "ColorTier enum, truecolor RGB palette, tier-aware Theme dataclass"
      contains: "class ColorTier"
    - path: "kflash/ansi.py"
      provides: "ANSI string utilities and terminal width detection"
      exports: ["strip_ansi", "display_width", "pad_to_width", "get_terminal_width"]
  key_links:
    - from: "kflash/theme.py"
      to: "ColorTier enum"
      via: "detect_color_tier() replaces supports_color() for tier selection"
      pattern: "detect_color_tier"
    - from: "kflash/theme.py"
      to: "PALETTE dict"
      via: "rgb_to_ansi() converts RGB tuples per detected tier"
      pattern: "rgb_to_ansi"
---

<objective>
Build the rendering primitives that all panel code (Phases 11-14) depends on: truecolor theme with fallback tiers and ANSI-aware string utilities.

Purpose: Panels need correct visual alignment (ANSI-aware width) and rich colors (truecolor RGB) to render the zen mockup design.
Output: Upgraded kflash/theme.py with ColorTier and truecolor palette; new kflash/ansi.py with string utilities.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-rendering-foundation/10-RESEARCH.md
@kflash/theme.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade theme.py with ColorTier and truecolor palette</name>
  <files>kflash/theme.py</files>
  <action>
Upgrade kflash/theme.py with the following changes:

1. Add `ColorTier` enum with values: TRUECOLOR, ANSI256, ANSI16, NONE

2. Add `detect_color_tier()` function that replaces `supports_color()`:
   - NO_COLOR env var -> NONE
   - FORCE_COLOR env var -> TRUECOLOR
   - Not a TTY -> NONE
   - TERM=dumb -> NONE
   - Windows: enable VT mode, then check COLORTERM/TERM as below
   - COLORTERM in {truecolor, 24bit} -> TRUECOLOR
   - TERM contains '256color' -> ANSI256
   - Otherwise -> ANSI16

3. Add PALETTE dict with RGB tuples from the zen mockup:
   border=(100,160,180), header=(130,200,220), label=(140,180,160), prompt=(180,220,200),
   text=(200,210,215), value=(220,225,230), subtle=(100,120,130),
   green=(80,200,120), yellow=(220,190,60), red=(200,80,80)

4. Add `rgb_to_ansi(r, g, b, tier, bg=False)` that converts RGB to escape sequence per tier:
   - NONE -> ""
   - TRUECOLOR -> `\033[38;2;R;G;Bm` (or 48 for bg)
   - ANSI256 -> `\033[38;5;Nm` using `_rgb_to_256()` helper
   - ANSI16 -> `\033[9Xm` or `\033[3Xm` using `_rgb_to_16()` helper

5. Add `_rgb_to_256(r,g,b)` helper: greyscale ramp check (abs diffs < 10), then 6x6x6 cube formula

6. Add `_rgb_to_16(r,g,b)` helper: brightness threshold for bright/dim prefix, dominant channel selection

7. Update Theme dataclass to include new fields: border, header, label, prompt, text, value, subtle, plus existing semantic fields (success, warning, error, info, phase). Add `tier: ColorTier` field. Keep bold, dim, reset. Remove marker_* fields (those will be derived from semantic colors by downstream code). Keep menu_title and menu_border for backward compat, but derive from new palette.

8. Update `_build_theme(tier)` to construct Theme by calling `rgb_to_ansi()` for each palette color. For header, combine bold + color. Map semantic fields: success=green, warning=yellow, error=red, info=header, phase=border. Map menu_title=bold, menu_border=border.

9. Keep `supports_color()` as a thin wrapper (`return detect_color_tier() != ColorTier.NONE`) for backward compatibility.

10. Update `get_theme()` to call `detect_color_tier()` and `_build_theme(tier)`. Keep caching pattern. Keep `reset_theme()` and `clear_screen()` unchanged.

Important: preserve the existing `_enable_windows_vt_mode()` function. Call it in `detect_color_tier()` on Windows before checking COLORTERM/TERM.
  </action>
  <verify>
Run `python -c "from kflash.theme import get_theme, ColorTier, detect_color_tier; t = get_theme(); print(t.tier); print(repr(t.border)); print(repr(t.success))"` — should print a ColorTier value and non-empty escape sequences (or empty if NO_COLOR).

Run `python -c "from kflash.theme import rgb_to_ansi, ColorTier; print(repr(rgb_to_ansi(100,160,180, ColorTier.TRUECOLOR)))"` — should print `'\x1b[38;2;100;160;180m'`.

Run `python -c "from kflash.theme import supports_color; print(supports_color())"` — backward compat check.
  </verify>
  <done>
Theme detects color tier (truecolor/256/16/none), PALETTE stores RGB tuples, rgb_to_ansi converts per tier, Theme dataclass has all panel structure + semantic fields, backward compat maintained via supports_color() wrapper.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ansi.py with string utilities and terminal width</name>
  <files>kflash/ansi.py</files>
  <action>
Create new module kflash/ansi.py with:

1. Module docstring explaining purpose: ANSI-aware string utilities for panel rendering.

2. `_ANSI_RE` compiled regex: `re.compile(r"\033\[[0-9;]*[A-Za-z]")` — matches all CSI sequences.

3. `strip_ansi(s: str) -> str` — removes all ANSI escape sequences using _ANSI_RE.sub("", s).

4. `display_width(s: str) -> int` — strips ANSI, then iterates characters using `unicodedata.east_asian_width()`. Width categories "W" and "F" count as 2, all others as 1. Import unicodedata at module level.

5. `pad_to_width(s: str, target_width: int, fill: str = " ") -> str` — computes current display_width, appends fill chars to reach target_width. If already >= target, returns s unchanged.

6. `get_terminal_width(default: int = 80, minimum: int = 40) -> int` — uses `shutil.get_terminal_size((default, 24)).columns`, returns `max(result, minimum)`. Import shutil at module level.

Use `from __future__ import annotations` at top. Keep it minimal and well-documented.
  </action>
  <verify>
Run `python -c "from kflash.ansi import strip_ansi, display_width, pad_to_width, get_terminal_width; assert strip_ansi('\033[91mhello\033[0m') == 'hello'; assert display_width('\033[91mhello\033[0m') == 5; assert len(pad_to_width('hi', 10)) == 10; w = get_terminal_width(); print(f'All passed. Terminal width: {w}')"` — should print success message.
  </verify>
  <done>
ansi.py exports strip_ansi, display_width, pad_to_width, get_terminal_width. All functions handle ANSI escape sequences correctly. Terminal width detected at call time with minimum clamp.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from kflash.theme import get_theme, ColorTier; t = get_theme(); assert isinstance(t.tier, ColorTier)"` — tier detection works
2. `python -c "from kflash.theme import rgb_to_ansi, ColorTier; assert rgb_to_ansi(0,0,0,ColorTier.NONE) == ''; assert '\033[38;2;' in rgb_to_ansi(100,160,180, ColorTier.TRUECOLOR)"` — RGB conversion correct per tier
3. `python -c "from kflash.ansi import strip_ansi, display_width, pad_to_width; s = '\033[91mtest\033[0m'; assert strip_ansi(s) == 'test'; assert display_width(s) == 4; p = pad_to_width(s, 10); assert display_width(p) == 10"` — ANSI utilities correct
4. `python -c "from kflash.ansi import get_terminal_width; w = get_terminal_width(); assert w >= 40"` — terminal width detected with minimum
5. `python -c "from kflash.theme import supports_color"` — backward compat import works
</verification>

<success_criteria>
- ColorTier enum with 4 tiers exists in theme.py
- detect_color_tier() detects tier from environment variables and terminal state
- PALETTE dict stores all 10 RGB color tuples from zen mockup
- rgb_to_ansi() converts RGB to correct escape sequence for any tier
- Theme dataclass includes panel structure fields (border, header, label, prompt, text, value, subtle) plus semantic fields (success, warning, error, info, phase)
- ansi.py provides strip_ansi, display_width, pad_to_width, get_terminal_width
- All existing theme.py callers continue working (backward compat)
</success_criteria>

<output>
After completion, create `.planning/phases/10-rendering-foundation/10-01-SUMMARY.md`
</output>
