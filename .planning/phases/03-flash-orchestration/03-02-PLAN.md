---
phase: 03-flash-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - klipper-flash/flash.py
  - klipper-flash/output.py
  - klipper-flash/build.py
autonomous: true

must_haves:
  truths:
    - "User runs --device KEY and full workflow executes: discover, config, build, stop klipper, flash, restart klipper"
    - "User runs without --device and sees interactive numbered menu of connected devices"
    - "Console output shows phase labels: [Discovery], [Config], [Build], [Flash]"
    - "Build and flash operations have timeouts (build: 300s, flash: 60s)"
    - "Success summary shows device name, flash method, elapsed time"
    - "Failure shows what failed, command run, and recovery hint"
  artifacts:
    - path: "klipper-flash/flash.py"
      provides: "cmd_flash orchestrator with full workflow"
      exports: ["cmd_flash"]
    - path: "klipper-flash/output.py"
      provides: "Phase-labeled output method"
      contains: ["def phase"]
    - path: "klipper-flash/build.py"
      provides: "Build with timeout support"
      contains: ["TIMEOUT_BUILD", "timeout"]
  key_links:
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/service.py"
      via: "klipper_service_stopped context manager"
      pattern: "with klipper_service_stopped"
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/flasher.py"
      via: "flash_device call"
      pattern: "flash_device\\("
    - from: "klipper-flash/flash.py"
      to: "klipper-flash/discovery.py"
      via: "scan_serial_devices for interactive selection"
      pattern: "scan_serial_devices"
---

<objective>
Wire the service and flasher modules into flash.py to create the complete end-to-end workflow with phase-labeled output, interactive device selection, and proper error handling.

Purpose: This completes Phase 3 by integrating all components into a single-command experience. The user runs `flash.py --device octopus` or `flash.py` (interactive) and the tool handles discovery, config, build, service lifecycle, and flash with clear phase output.

Output: Updated flash.py with cmd_flash orchestrator, updated output.py with phase() method, updated build.py with timeout support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-flash-orchestration/03-RESEARCH.md
@.planning/phases/03-flash-orchestration/03-CONTEXT.md
@.planning/phases/03-flash-orchestration/03-01-SUMMARY.md

@klipper-flash/flash.py
@klipper-flash/output.py
@klipper-flash/build.py
@klipper-flash/discovery.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add phase() method to output.py and TIMEOUT_BUILD to build.py</name>
  <files>klipper-flash/output.py, klipper-flash/build.py</files>
  <action>
**output.py changes:**

Add to Output Protocol:
```python
def phase(self, phase_name: str, message: str) -> None: ...
```

Add to CliOutput class:
```python
def phase(self, phase_name: str, message: str) -> None:
    """Output a phase-labeled message."""
    print(f"[{phase_name}] {message}")
```

Add to NullOutput class:
```python
def phase(self, phase_name: str, message: str) -> None: pass
```

**build.py changes:**

Add constant at module level (after imports):
```python
TIMEOUT_BUILD = 300  # 5 minutes for make operations
```

Update run_build() to accept optional timeout parameter:
```python
def run_build(klipper_dir: str, timeout: int = TIMEOUT_BUILD) -> BuildResult:
```

Add timeout to the make -j subprocess.run call:
```python
build_result = subprocess.run(
    ["make", f"-j{nproc}"],
    cwd=str(klipper_path),
    timeout=timeout,  # NEW
)
```

Wrap in try/except to handle TimeoutExpired:
```python
try:
    build_result = subprocess.run(...)
except subprocess.TimeoutExpired:
    return BuildResult(
        success=False,
        elapsed_seconds=time.monotonic() - start_time,
        error_message=f"Build timed out after {timeout}s",
    )
```

Also add timeout to the make clean call (use same timeout).

Note: menuconfig intentionally has NO timeout (user interaction).
  </action>
  <verify>
Import test: `python -c "from output import CliOutput; o = CliOutput(); o.phase('Test', 'message'); print('OK')"`
Build import: `python -c "from build import TIMEOUT_BUILD; print(f'Timeout: {TIMEOUT_BUILD}s')"`
  </verify>
  <done>output.py has phase() method on Protocol, CliOutput, and NullOutput. build.py has TIMEOUT_BUILD=300 constant and run_build() handles TimeoutExpired.</done>
</task>

<task type="auto">
  <name>Task 2: Create cmd_flash orchestrator in flash.py with full workflow</name>
  <files>klipper-flash/flash.py</files>
  <action>
Create new function `cmd_flash(registry, device_key: Optional[str], out) -> int` that orchestrates:

**Phase 1 - Discovery:**
```python
out.phase("Discovery", "Scanning for USB devices...")
devices = scan_serial_devices()
```

If device_key is None (interactive mode):
- If no devices found: error "No USB devices found"
- Show numbered list: `[1] octopus (stm32h723) - /dev/serial/by-id/...`
- Prompt for selection
- Look up device key from selection

If device_key provided:
- Verify device exists in registry (error if not)
- Find matching USB device (error if not connected)

**Phase 2 - Config:**
```python
out.phase("Config", f"Loading config for {entry.name}...")
```
- Load cached config (same as existing cmd_build)
- Run menuconfig (no timeout - user interaction)
- Save config to cache
- Validate MCU

**Phase 3 - Build:**
```python
out.phase("Build", "Running make clean + make...")
```
- Call run_build() with timeout (from build.py)
- Report firmware size on success

**Phase 4 - Pre-flash verification:**
```python
out.phase("Flash", "Verifying device connection...")
```
- Call verify_device_path() from flasher.py
- Call verify_passwordless_sudo() from service.py - if fails, let sudo prompt naturally per CONTEXT.md decision

**Phase 5 - Flash with service lifecycle:**
```python
out.phase("Flash", "Stopping Klipper...")
start_time = time.monotonic()
with klipper_service_stopped():
    out.phase("Flash", "Flashing firmware...")
    result = flash_device(...)
out.phase("Flash", "Klipper restarted")
```

**Phase 6 - Summary:**
```python
elapsed = time.monotonic() - start_time
if result.success:
    out.success(f"Flashed {entry.name} via {result.method} in {elapsed:.1f}s")
    return 0
else:
    out.error(f"Flash failed: {result.error_message}")
    out.error(f"Command: {result.method}")  # What was tried
    out.error("Recovery: Power cycle the board and try again")
    return 1
```

**Update main() to route to cmd_flash:**
- Change `elif args.device:` to call `cmd_flash(registry, args.device, out)` instead of `cmd_build`
- Keep cmd_build for a potential future --build-only flag (or remove it - cmd_flash now handles build)

**Update argparse:**
- Update --device help text: "Device key to build and flash"
- Update epilog: mention flash workflow is now available

**Late imports in cmd_flash:**
```python
from discovery import scan_serial_devices, match_device
from config import ConfigManager
from build import run_menuconfig, run_build, TIMEOUT_BUILD
from service import klipper_service_stopped, verify_passwordless_sudo
from flasher import flash_device, verify_device_path
from errors import ConfigError, DiscoveryError
```
  </action>
  <verify>
Syntax check: `python -m py_compile flash.py`
Help text: `python flash.py --help` shows updated description
Import path: `python -c "import flash; print('OK')"`
  </verify>
  <done>flash.py has cmd_flash() that orchestrates full workflow with phase labels. --device flag triggers cmd_flash. Interactive mode shows numbered device list when no --device provided.</done>
</task>

<task type="auto">
  <name>Task 3: Add interactive device selection to cmd_flash</name>
  <files>klipper-flash/flash.py</files>
  <action>
In cmd_flash, when device_key is None, implement interactive selection:

```python
if device_key is None:
    # Interactive mode
    out.phase("Discovery", "Scanning for USB devices...")
    usb_devices = scan_serial_devices()

    if not usb_devices:
        out.error("No USB devices found. Connect a board and try again.")
        return 1

    # Load registry to cross-reference
    data = registry.load()
    matched, unmatched = find_registered_devices(usb_devices, data.devices)

    if not matched:
        out.error("No registered devices connected.")
        out.info("Discovery", "Found USB devices but none are registered:")
        for device in usb_devices:
            out.device_line("??", device.filename, "")
        out.info("Discovery", "Run --add-device to register a board first.")
        return 1

    # Show numbered list of connected registered devices
    out.phase("Discovery", f"Found {len(matched)} registered device(s):")
    for i, (entry, device) in enumerate(matched):
        out.device_line(str(i + 1), f"{entry.key} ({entry.mcu})", device.path)

    # Single device: auto-select with confirmation
    if len(matched) == 1:
        entry, device = matched[0]
        if out.confirm(f"Flash {entry.name}?", default=True):
            device_key = entry.key
            device_path = device.path
        else:
            out.info("Discovery", "Cancelled")
            return 0
    else:
        # Multiple devices: prompt for selection
        for attempt in range(3):
            choice = out.prompt("Select device number", default="1")
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(matched):
                    entry, device = matched[idx]
                    device_key = entry.key
                    device_path = device.path
                    break
                out.warn(f"Invalid selection. Choose 1-{len(matched)}.")
            except ValueError:
                out.warn("Please enter a number.")
        else:
            out.error("Too many invalid selections.")
            return 1
```

This provides the interactive numbered menu when no --device flag is given, per CONTEXT.md decision.

Also update argparse to make --device optional (not required), so `flash.py` without args triggers interactive mode:
- Remove `args.device` check from "No command specified" error
- Instead, if no management flags AND no device, call cmd_flash with device_key=None
  </action>
  <verify>
`python flash.py --help` shows --device as optional
Syntax check: `python -m py_compile flash.py`
  </verify>
  <done>Running flash.py without --device shows interactive numbered list of connected registered devices. Single device auto-selects with confirmation. Multiple devices prompt for number.</done>
</task>

</tasks>

<verification>
Full syntax check:
```bash
cd klipper-flash
python -m py_compile flash.py output.py build.py
```

Import chain works:
```bash
python -c "
from flash import cmd_flash
from output import CliOutput
from build import TIMEOUT_BUILD
from service import klipper_service_stopped
from flasher import flash_device
print('All imports OK')
"
```

Help text updated:
```bash
python flash.py --help
# Should mention flash workflow, --device for build+flash
```

Note: Full end-to-end test requires running on Pi with actual devices and Klipper service.
</verification>

<success_criteria>
- output.py has phase() method on Protocol, CliOutput, and NullOutput
- build.py has TIMEOUT_BUILD=300 and run_build() handles TimeoutExpired
- flash.py has cmd_flash() orchestrating: discovery -> config -> build -> flash
- flash.py --device KEY runs full workflow with phase labels
- flash.py (no args) shows interactive device selection
- Phase labels use [Discovery], [Config], [Build], [Flash] format
- Success shows device name, flash method, elapsed time
- Failure shows what failed with recovery hint
- All modules compile without syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-flash-orchestration/03-02-SUMMARY.md`
</output>
