---
phase: 03-flash-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - klipper-flash/service.py
  - klipper-flash/flasher.py
  - klipper-flash/errors.py
  - klipper-flash/models.py
autonomous: true

must_haves:
  truths:
    - "Klipper service stops before flash and restarts after, even on exception or Ctrl+C"
    - "Katapult flashtool.py is attempted first for flash operations"
    - "If Katapult fails, make flash is automatically tried as fallback"
    - "Passwordless sudo is verified before any service operation"
  artifacts:
    - path: "klipper-flash/service.py"
      provides: "KlipperServiceManager context manager with guaranteed restart"
      exports: ["klipper_service_stopped", "verify_passwordless_sudo"]
    - path: "klipper-flash/flasher.py"
      provides: "FlashManager with dual-method flash and timeout support"
      exports: ["flash_device", "FlashResult"]
    - path: "klipper-flash/errors.py"
      provides: "ServiceError and FlashError exception types"
      contains: ["ServiceError", "FlashError"]
    - path: "klipper-flash/models.py"
      provides: "FlashResult dataclass for flash outcomes"
      contains: ["FlashResult"]
  key_links:
    - from: "klipper-flash/service.py"
      to: "subprocess"
      via: "systemctl stop/start klipper"
      pattern: "subprocess\\.run.*systemctl"
    - from: "klipper-flash/flasher.py"
      to: "katapult/scripts/flashtool.py"
      via: "subprocess call"
      pattern: "flashtool\\.py"
    - from: "klipper-flash/flasher.py"
      to: "make flash"
      via: "subprocess call on failure"
      pattern: "make.*flash"
---

<objective>
Create the service lifecycle manager and flasher module that implement guaranteed Klipper restart and dual-method (Katapult + make flash) flashing.

Purpose: These are the core safety and functionality modules for flash operations. The service manager guarantees Klipper is always restarted (SRVC-01, SRVC-02), and the flasher implements the Katapult-first-with-fallback strategy (FLSH-01, FLSH-02, FLSH-03).

Output: Two new modules (service.py, flasher.py) plus extensions to errors.py and models.py.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-flash-orchestration/03-RESEARCH.md
@.planning/phases/03-flash-orchestration/03-CONTEXT.md

@klipper-flash/errors.py
@klipper-flash/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend errors.py and models.py with flash-related types</name>
  <files>klipper-flash/errors.py, klipper-flash/models.py</files>
  <action>
Add to errors.py (after BuildError):
```python
class ServiceError(KlipperFlashError):
    """Klipper service lifecycle errors: stop/start failures."""
    pass


class FlashError(KlipperFlashError):
    """Flash operation failures: Katapult, make flash, device not found."""
    pass
```

Add to models.py (after BuildResult):
```python
@dataclass
class FlashResult:
    """Result of a flash operation."""
    success: bool
    method: str  # "katapult" or "make_flash"
    elapsed_seconds: float = 0.0
    error_message: Optional[str] = None
```

Remove the "Phase 3 will add:" comment from errors.py since we're adding them now.
  </action>
  <verify>
Import test: `python -c "from errors import ServiceError, FlashError; from models import FlashResult; print('OK')"`
  </verify>
  <done>ServiceError, FlashError classes exist in errors.py; FlashResult dataclass exists in models.py with success, method, elapsed_seconds, error_message fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create service.py with KlipperServiceManager context manager</name>
  <files>klipper-flash/service.py</files>
  <action>
Create service.py implementing:

1. `verify_passwordless_sudo() -> bool` - Run `sudo -n true` with 5s timeout, return True if exit code 0.

2. `@contextmanager klipper_service_stopped(timeout: int = 30)` - Context manager that:
   - On entry: Calls `_stop_klipper(timeout)` which runs `sudo systemctl stop klipper` with timeout
   - Yields control
   - On exit (in finally block): Calls `_start_klipper(timeout)` which runs `sudo systemctl start klipper`
   - The finally block must NOT raise exceptions that mask the original error - catch exceptions, print warning, but don't re-raise

3. Helper functions `_stop_klipper(timeout)` and `_start_klipper(timeout)`:
   - Use `subprocess.run(["sudo", "systemctl", "stop/start", "klipper"], capture_output=True, text=True, timeout=timeout)`
   - _stop_klipper raises ServiceError on failure
   - _start_klipper prints warning on failure but does NOT raise (we're in finally)

Constants:
```python
TIMEOUT_SERVICE = 30  # seconds for systemctl operations
```

Key patterns from research:
- Use `from contextlib import contextmanager`
- The finally block MUST execute even on KeyboardInterrupt
- Don't suppress the original exception by raising in finally
  </action>
  <verify>
Import test: `python -c "from service import klipper_service_stopped, verify_passwordless_sudo; print('OK')"`

The full functional test requires running on the Pi (service.py talks to systemctl).
  </verify>
  <done>service.py exists with klipper_service_stopped context manager that stops Klipper on enter and restarts on exit (even on exception). verify_passwordless_sudo() returns bool for sudo -n true check.</done>
</task>

<task type="auto">
  <name>Task 3: Create flasher.py with dual-method flash and timeout support</name>
  <files>klipper-flash/flasher.py</files>
  <action>
Create flasher.py implementing:

1. Constants (from CONTEXT.md and research):
```python
TIMEOUT_FLASH = 60  # seconds for flash operations (CONTEXT.md decision)
```

2. `flash_device(device_path, firmware_path, katapult_dir, klipper_dir, timeout=TIMEOUT_FLASH) -> FlashResult`:
   - Call `_try_katapult_flash()` first
   - If Katapult succeeds, return FlashResult(success=True, method="katapult")
   - If Katapult fails, print "[Flash] Katapult failed, trying make flash..." and call `_try_make_flash()`
   - Return result from whichever method succeeds (or last failure)
   - Track elapsed time with `time.monotonic()`

3. `_try_katapult_flash(device_path, firmware_path, katapult_dir, timeout) -> FlashResult`:
   - Build flashtool path: `Path(katapult_dir).expanduser() / "scripts" / "flashtool.py"`
   - Check flashtool.py exists, return FlashResult(success=False) if not
   - Run `python3 flashtool.py -d {device_path} -f {firmware_path}` with timeout
   - Handle subprocess.TimeoutExpired -> FlashResult with timeout error
   - Return success=True if returncode == 0, else success=False with stderr

4. `_try_make_flash(device_path, klipper_dir, timeout) -> FlashResult`:
   - Run `make FLASH_DEVICE={device_path} flash` with cwd=klipper_dir, timeout
   - Handle subprocess.TimeoutExpired -> FlashResult with timeout error
   - Return success=True if returncode == 0, else success=False with stderr

5. `verify_device_path(device_path: str) -> None`:
   - Check `Path(device_path).exists()`
   - Raise DiscoveryError if not: "Device no longer connected: {path}\nThe device may have been unplugged during build."

Key patterns from research:
- Use `subprocess.run(..., capture_output=True, text=True, timeout=timeout)`
- subprocess.run with timeout handles process cleanup properly
- Return FlashResult on all paths (don't raise for flash failures, let caller decide)
  </action>
  <verify>
Import test: `python -c "from flasher import flash_device, verify_device_path, TIMEOUT_FLASH; print('OK')"`

Verify FlashResult import works: `python -c "from flasher import flash_device; from models import FlashResult; print('OK')"`
  </verify>
  <done>flasher.py exists with flash_device() that tries Katapult first then make flash, returns FlashResult. verify_device_path() raises DiscoveryError if device not found. TIMEOUT_FLASH=60 constant defined.</done>
</task>

</tasks>

<verification>
All imports work without errors:
```bash
cd klipper-flash
python -c "from errors import ServiceError, FlashError"
python -c "from models import FlashResult"
python -c "from service import klipper_service_stopped, verify_passwordless_sudo"
python -c "from flasher import flash_device, verify_device_path, TIMEOUT_FLASH"
```

No syntax errors in any module:
```bash
python -m py_compile errors.py models.py service.py flasher.py
```
</verification>

<success_criteria>
- errors.py has ServiceError and FlashError classes
- models.py has FlashResult dataclass with success, method, elapsed_seconds, error_message fields
- service.py has klipper_service_stopped context manager with finally-block restart guarantee
- service.py has verify_passwordless_sudo() function
- flasher.py has flash_device() with Katapult-first, make-flash-fallback logic
- flasher.py has verify_device_path() that raises DiscoveryError
- All modules import cleanly with no circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-flash-orchestration/03-01-SUMMARY.md`
</output>
